<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6248994341461229"
     crossorigin="anonymous"></script>
        <title>Ethereum White Paper - Joohwan&#39;s blog</title><meta name="Description" content="Hello this is description"><meta property="og:title" content="Ethereum White Paper" />
<meta property="og:description" content="SKKRPTO 11기
Vitalik Buterin. (2014). Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform. Retrieved from https://ethereum.org/en/whitepaper/
Vitalik Buterin. (2014). 차세대 스마트 컨트랙트와 탈중앙화된 어플리케이션 플랫폼. (EthereumKorea 편역) Retrieved from https://ethereum.org/ko/whitepaper/
서론 사토시 나카모토에 의해 2009 년 개발된 비트코인은 종종 화폐와 통화분야에서 매우 근본적인 혁신으로 묘사되어 왔는데, 이것은 비트코인이 어떤 담보나 내재적인 가치를 가지지 않으며, 중앙화된 발행기관이나 통제기관도 없는 디지털 자산의 첫 번째 사례였기 때문이다. 하지만 비트코인 실험의 더욱 중요한 측면은 비트코인을 떠받치고 있는 분산 합의 수단으로서의 블록체인 기술이며, 이에 대한 관심이 급격하게 늘어나고 있다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jwanp.github.io/posts/ethereum-white-paper/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-26T15:29:59+09:00" />
<meta property="article:modified_time" content="2023-03-26T15:29:59+09:00" /><meta property="og:site_name" content="Hello this is title" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ethereum White Paper"/>
<meta name="twitter:description" content="SKKRPTO 11기
Vitalik Buterin. (2014). Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform. Retrieved from https://ethereum.org/en/whitepaper/
Vitalik Buterin. (2014). 차세대 스마트 컨트랙트와 탈중앙화된 어플리케이션 플랫폼. (EthereumKorea 편역) Retrieved from https://ethereum.org/ko/whitepaper/
서론 사토시 나카모토에 의해 2009 년 개발된 비트코인은 종종 화폐와 통화분야에서 매우 근본적인 혁신으로 묘사되어 왔는데, 이것은 비트코인이 어떤 담보나 내재적인 가치를 가지지 않으며, 중앙화된 발행기관이나 통제기관도 없는 디지털 자산의 첫 번째 사례였기 때문이다. 하지만 비트코인 실험의 더욱 중요한 측면은 비트코인을 떠받치고 있는 분산 합의 수단으로서의 블록체인 기술이며, 이에 대한 관심이 급격하게 늘어나고 있다."/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://jwanp.github.io/posts/ethereum-white-paper/" /><link rel="prev" href="http://jwanp.github.io/posts/bitcoin-white-paper/" /><link rel="next" href="http://jwanp.github.io/posts/minting-nft/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Ethereum White Paper",
        "inLanguage": "en",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/jwanp.github.io\/posts\/ethereum-white-paper\/"
        },"image": ["https:\/\/user-images.githubusercontent.com\/77142334\/227780652-4a867037-5843-4d78-b5e7-9c27f6203e23.png"],"genre": "posts","keywords": "block-chain","wordcount":  7664 ,
        "url": "http:\/\/jwanp.github.io\/posts\/ethereum-white-paper\/","datePublished": "2023-03-26T15:29:59+09:00","dateModified": "2023-03-26T15:29:59+09:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "박주환"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Joohwan&#39;s blog">Joohwan&#39;s dev blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="/chat/"> Chat </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Joohwan&#39;s blog">Joohwan&#39;s dev blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="/chat/" title="">Chat</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Ethereum White Paper</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>박주환</a></span>&nbsp;<span class="post-category">included in <a href="/categories/tech/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Tech</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-03-26">2023-03-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;7664 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;36 minutes&nbsp;</div>
        </div><div class="featured-image"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/ethereum-white-paper/ethereum-main.png"
        data-srcset="/images/ethereum-white-paper/ethereum-main.png, /images/ethereum-white-paper/ethereum-main.png 1.5x, /images/ethereum-white-paper/ethereum-main.png 2x"
        data-sizes="auto"
        alt="/images/ethereum-white-paper/ethereum-main.png"
        title="/images/ethereum-white-paper/ethereum-main.png" width="1843" height="1248" /></div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#서론">서론</a></li>
    <li><a href="#역사history">역사(History)</a>
      <ul>
        <li><a href="#상태변환시스템으로서의--비트코인bitcoin-as-a-state-transition-system">상태변환시스템으로서의  비트코인(Bitcoin As A State Transition System)</a></li>
        <li><a href="#채굴mining">채굴(Mining)</a></li>
        <li><a href="#머클트리merkle-trees">머클트리(Merkle Trees)</a></li>
        <li><a href="#블록체인--기술을--이용한--다른--응용--사례--alternative-blockchain-applications">블록체인  기술을  이용한  다른  응용  사례  (Alternative Blockchain Applications)</a></li>
        <li><a href="#스크립팅scripting">스크립팅(Scripting)</a></li>
      </ul>
    </li>
    <li><a href="#이더리움ethereum">이더리움(Ethereum)</a>
      <ul>
        <li><a href="#이더리움--어카운트ethereum-accounts">이더리움  어카운트(Ethereum Accounts)</a></li>
        <li><a href="#메시지와--트랜잭션messages-and-transactions">메시지와  트랜잭션(Messages and Transactions)</a></li>
        <li><a href="#메시지messages">메시지(Messages)</a></li>
        <li><a href="#이더리움--상태--변환--함수ethereum-state-transition-function">이더리움  상태  변환  함수(Ethereum State Transition Function)</a></li>
        <li><a href="#코드--실행code-execution">코드  실행(Code Execution)</a></li>
        <li><a href="#블록체인과--채굴blockchain-and-mining">블록체인과  채굴(Blockchain and Mining)</a></li>
      </ul>
    </li>
    <li><a href="#그--밖의--이슈miscellanea-and-concerns">그  밖의  이슈(Miscellanea And Concerns)</a>
      <ul>
        <li><a href="#수수료fees">수수료(Fees)</a></li>
        <li><a href="#채굴--중앙집중화mining-centralization">채굴  중앙집중화(Mining Centralization)</a></li>
        <li><a href="#확장성scalability">확장성(Scalability)</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><p><strong>SKKRPTO 11기</strong></p>
<p><strong>Vitalik Buterin. (2014). Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform. Retrieved from <a href="https://ethereum.org/en/whitepaper/" target="_blank" rel="noopener noreffer ">https://ethereum.org/en/whitepaper/</a></strong></p>
<p><strong>Vitalik Buterin. (2014). 차세대 스마트 컨트랙트와 탈중앙화된 어플리케이션 플랫폼. (EthereumKorea 편역) Retrieved from <a href="https://ethereum.org/ko/whitepaper/" target="_blank" rel="noopener noreffer ">https://ethereum.org/ko/whitepaper/</a></strong></p>
<h2 id="서론">서론</h2>
<blockquote>
<p>사토시  나카모토에  의해  2009 년  개발된  비트코인은  종종  화폐와  통화분야에서  매우  근본적인  혁신으로 묘사되어  왔는데,  이것은  비트코인이  어떤  <strong>담보나 내재적인  가치를  가지지  않으며,  중앙화된  발행기관이나 통제기관도  없는</strong>  디지털  자산의  첫  번째  사례였기  때문이다.  하지만  비트코인  실험의  더욱  중요한  측면은 비트코인을  떠받치고  있는  분산  합의  수단으로서의  블록체인  기술이며,  이에  대한  관심이  급격하게  늘어나고  있다.</p>
</blockquote>
<p>비트코인의 혁신 - 담보나 내재적인 가치를 가지지 않으며 통제기관 없이 가치를 유지하는 첫번째 p2p 디지털 화폐</p>
<p><em>원문 에서의 추가 내용으로 비트코인이 돈 그 자체 이상으로는 쓰일 수 없는 한계점에 대해서 나온다.</em></p>
<p>비트코인의 문제점 - first-to-file system: 애매한 상황에서 이것을 세부 조정할 수 있는 방법이 없다.
ex) 50BTC 를 가진 개체가 50BTC 를 동시에 2명에게 보냈을때 먼저 확인된 거래만 처리된다.
-&gt; <strong>조건을 걸 수 있는데 작업증명에만 의존하여 많은 기능들이 제한 되는것을 말하고 있는것 같다.</strong></p>
<blockquote>
<p>블록체인  기술을  이용한  대안적  어플리케이션들에는  다음과  같은  것들이  자주  거론되고  있다.  사용자  정의 화폐와  금융상품을  블록체인  위에  표현하는  <strong>컬러드  코인(&ldquo;color
ed  coins&rdquo;)</strong>,  물리적  대상의  소유권을  표현하는 스마트  자산(&ldquo;smart  property&rdquo;),  도메인  이름과  같은  비동질적  자산을  기록하는  <strong>네임코인(&ldquo;Namecoin&rdquo;)</strong>,  임의적인 계약규칙을  구현한  코드에  의해  다지털  자산을  관리하는  좀  더  복잡한  형태의  <strong>스마트  컨트랙트  (&ldquo;smart contracts&rdquo;)</strong>, 더  나아가  블록체인을  기반으로  한  탈중앙화된  <strong>자율  조직(&ldquo;decentralized autonomous organizations&rdquo;, DAOs)</strong> 등이다.</p>
</blockquote>
<blockquote>
<p><strong>이더리움이  제공하려는  것은  완벽한  튜링완전(turing-complete)  프로그래밍  언어가  심어진  블록체인이다.</strong>  이 프로그래밍  언어는,  코딩  된  규칙에  따라  &lsquo;어떤  상태&rsquo;를  다르게  변환시키는  기능(arbitrary  state  transition functions)이  포함된  &ldquo;계약(contracts)&ldquo;을  유저들이  작성할  수  있게  함으로써  앞서  설명한  시스템들을  구현 가능하게  할  뿐만  아니라  우리가  아직  상상하지  못한  다른  많은  어플리케이션들도  매우  쉽게  만들  수  있도록 도와줄  것이다.</p>
</blockquote>
<p>이더리움 - 블록체인에 프로그래밍 언어를 심어서 다양한 기능들을 수행할수 있게 한다.</p>
<h2 id="역사history">역사(History)</h2>
<blockquote>
<p>분산화된  디지털  통화의  개념은,  재산등록  같은  대안  어플리케이션과  마찬가지로  지난  수십  년간  우리  주변에  있었다. 1980~90 년대의  익명  <!-- raw HTML omitted --><strong>e-cash  프로토콜</strong><!-- raw HTML omitted -->은  주로  ‘Chaumian blinding’으로  알려진  ‘로우레벨 Low-level cryptographic <strong>암호  알고리즘(cryptographic primitive)’ 에  기반하였고  개인정보를  강력하게  보호</strong>하는  화폐를 algorithms frequently used 제공하였으나  <strong>중앙집권적인  중개인에  의존</strong>했기  때문에  별다른  주목을  받지  못했다. 1998 년 to build computer security ‘Wei Dai’의  <a href="http://www.weidai.com/bmoney.txt" target="_blank" rel="noopener noreffer "><!-- raw HTML omitted --><strong>b-money</strong><!-- raw HTML omitted --></a>는  <strong>분산합의와  계산  퍼즐을 systems
풀게  하는  방식을  통해서  화폐를  발행</strong>하게  하는  아이디어를  최초로  제안하였지만  <strong>분산 합의를  실제로  어떻게  구현할지에  대한  자세한  방법은  제시하지  못했다</strong>. 2005 년에  ‘<!-- raw HTML omitted --><strong>Hall Finney</strong><!-- raw HTML omitted -->’는  <strong>&ldquo;재사용  가능한  작업증명(<a href="http://www.finney.org/~hal/rpow/" target="_blank" rel="noopener noreffer ">reusable proofs of work</a>)&rdquo;  개념을 소개하였다</strong>.  이  시스템은  b-money 의  아이디어에  Adam Back 의  ‘계산  난이도  해시캐시  퍼즐(computationally difficult Hashcash puzzles)’을  조합한  것이었다.  그러나  <strong>외부의  신뢰를  필요로  하는  컴퓨팅(trusted computing)</strong> 을  그 기반에  둠으로써,  이상을  구현하는  데에는  또  다시  실패했다. 2009 년  <!-- raw HTML omitted --><strong>&lsquo;사토시  나카모토&rsquo;</strong><!-- raw HTML omitted -->에  의해  처음  실제적으로 구현된  탈중앙화된  화폐는  <strong>공개키  암호방식</strong>을  통한  소유권  관리를  위해  사용되던  기존의  알고리즘을  ‘<strong>작업  증명(proof of work)</strong>’이라고  알려진  합의  알고리즘과  <strong>결합함으로써  가능하게  되었다.</strong></p>
</blockquote>
<p>화폐 프로토콜이 해결해야하는 과제</p>
<ol>
<li>개인정보를 강력하게 보호</li>
<li>분산 합의 구현</li>
<li>sybil 공격에 대한 방어</li>
</ol>
<ul>
<li>영어 원문 내용 추가 - 비트코인 전의 화폐 프로토콜의 문제점</li>
</ul>
<p>pre-Bitcoin currency protocols (비트코인이 나오기전 화폐 프로토콜들)은 sybil attack 과 같은 공격에 취약하다. <!-- raw HTML omitted --> sybil attack - 한 공격자가 한 서버에 시뮬레이트 된 노드들을 마구 할당받아서 과반을 확보하기 쉽다.</p>
<blockquote>
<p><strong>작업증명</strong>이  기반이  되는  작동방식은  매우  혁신적인  것이었는데,  이것은  두  가지의  문제들을  동시에  해결하기  때문이다. 첫째,  이것은  간단하면서도  상당히  효과적인  합의  알고리즘을  제공해주었다.  즉,  네트워크  상에  있는  모든 &lsquo;노드(node)&lsquo;들이  비트코인의  장부상태(state of the Bitcoin ledger)에  일어난  표준 업데이트의  집합(a set of canonical updates)에  <strong>공동으로  동의</strong>할  수  있도록  해주었다는 것이다.  둘째,  누구나 <strong>합의  프로세스에  참여할  수  있도록  허용</strong>해줌으로써  합의결정권에  대한 정치적  문제를  해결할  수  있을  뿐만  아니라  동시에  시빌공격(sybil attacks)도  방어해줄  수 있는  메커니즘을  제공했다.  이것은  합의  프로세스에  대한  참여의  조건으로  ‘특정한  리스트에 등록된  주체이어야만  한다’라는  어떤  형식적  장벽대신에,  <strong>경제적  장벽  -  각  노드의  결정권의 크기를  그  노드의  계산능력에  직접적으로  비례시키는  방식으로  대체하는  것이었다.</strong></p>
</blockquote>
<p>비트코인의 작업증명 방식은 분산 합의를 구현하면서 동시에 sybil 공격에 대한 방어 문제를 해결한다.</p>
<ul>
<li>누구나 합의 프로세스에 참여하게 해서 공동으로 동의할 수 있게 했다</li>
<li>노드의 결정권을 계산능력에 비례시켜서 sybil attack 에 대한 경제적인 장벽을 두었다.</li>
</ul>
<blockquote>
<p>이후로,  지분증명(proof of stake)이라는  새로운  방식의  합의  알고리즘이  등장했는데,  이는  각  노드가  가진  계산능력이 아니라  화폐의  보유량에  따라  각  노드의  결정권  정도를  계산해야  한다는  것이다.    이  두  방식의  상대적인  장점들에 대한  논의는  이  백서에서는  다루지  않겠지만,  두  방법  모두  암호화화폐의  기반으로서  사용될  수  있다는  점은 지적해두고자  한다.</p>
</blockquote>
<p>지분증명 - 노드의 계산능력이 아닌 화폐의 보유량에 따라 결정권을 할당.</p>
<h3 id="상태변환시스템으로서의--비트코인bitcoin-as-a-state-transition-system">상태변환시스템으로서의  비트코인(Bitcoin As A State Transition System)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png"
        data-srcset="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png, /images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png 1.5x, /images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png 2x"
        data-sizes="auto"
        alt="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png"
        title="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png" width="988" height="606" /></p>
<blockquote>
<p><strong>기술적인  관점에서  보았을  때,  비트코인과  같은  암호화  화폐의  장부는  하나의  상태변환시스템(state transition system)으로  생각해볼  수  있다.</strong>  이  시스템은,  현재  모든  비트코인의  소유권  현황으로  이루어진  하나의  <strong>“상태(state)”</strong> 와  이  현재  상태와  트랜잭션을  받아서  그  결과로써  새로운  상태를  출력해주는  <strong>“상태변환함수(state transition function)”</strong> 로  구성되어  있다.  표준  은행  시스템에  비유하자면  상태는  모든계좌잔고표(balance sheet)이고  트랜잭션은 A 에서  B 로  $X 를  송금하라는  요청이며,  상태변환함수에  의해  A 의  계좌에서는  $X 가  감소하고  B 의  계좌에서는 $X 가  증가한다.  만약  처음에  A 의  계좌에  있는  금액이  $X  이하인  경우에는  상태변환함수가  에러를  리턴한다. 이러한  상태변환를  비트코인  장부에서는  다음과  같이  정의할  수  있다.</p>
</blockquote>
<p>상태변환시스템</p>
<ol>
<li>상태(state) - 모든계좌잔고표 (각 소유주의 계좌에 돈이 얼마나 남아 있는지)</li>
<li>상태변환함수(state transition function) - 거래 요청에 따라 상태에 변화가 일어나는 함수</li>
</ol>
<blockquote>
<p><code>APPLY(S,TX) -&gt; S' or ERROR</code></p>
</blockquote>
<p>S: state <!-- raw HTML omitted -->
S&rsquo;: 새로운 state<!-- raw HTML omitted -->
TX: state transition function</p>
<p>TX는 새로운 상태 혹은 에러를 리턴</p>
<blockquote>
<p>은행  시스템  예시에서는  다음과  같다.</p>
</blockquote>
<blockquote>
<p><code>APPLY({ Alice: $50, Bob: $50 },&quot;send $20 from Alice to Bob&quot;) = { Alice: $30, Bob: $70 }</code></p>
</blockquote>
<blockquote>
<p><code>APPLY({ Alice: $50, Bob: $50 },&quot;send $70 from Alice to Bob&quot;) = ERROR</code></p>
</blockquote>
<blockquote>
<p>비트코인에서  &ldquo;<strong>상태(state)&ldquo;는  생성되었지만  아직  사용되지  않은  모든  코인들의  집합(기술적표현으로는  ‘소비되지  않은 트랜잭션출력’, UTXO(Unspent Transaction Outputs))이다.</strong>  각  <strong>UTXO</strong>들에는  각자의  <strong>코인금액</strong>이  표시되어  있고  이 UTXO 의  소유자(20byte 의  주소로  정의되는  암호화된  <strong>공개키(public key))정보가</strong>  들어  있다.  <strong>트랜잭션</strong>은  하나  이상의 입력(inputs)  및  출력을  포함한다.  각  <strong>입력에는  보내는  쪽  지갑주소에서  선택된  기존  UTXO 에  대한  참조정보와, 해당지갑주소에  대응되는  개인키(private key)가  생성한  암호화된  서명을  담고  있다</strong>.  <strong>그리고  각  출력들은  상태에 추가될  새로운  UTXO 정보를  가지고  있다.</strong>
상태변환함수  <code>APPLY(S,TX) -&gt; S'</code>  는  다음과  같이  정의할  수  있다.</p>
<ol>
<li>TX 의  각  입력에  대해:</li>
</ol>
<ul>
<li>만약  참조된  UTXO 가  <code>S</code>에  없다면,  에러를  리턴.</li>
<li>만약  서명이  UTXO 의  소유자와  매치되지  않으면,  에러를  리턴.</li>
</ul>
<ol start="2">
<li>만약  입력에  사용된  UTXO 들  금액의  합이  출력  UTXO 들  금액의  합보다  작으면,  에러를  리턴.</li>
<li>입력에  사용된  UTXO 가  삭제되고  출력  UTXO 가  추가된  <code>S</code>를  리턴.</li>
</ol>
</blockquote>
<blockquote>
<p>여기서  1 번의  첫번째  과정은  존재하지  않는  코인이  트랜잭션에  사용되는  것을  막기  위한  것이고  1 번의  두번째 과정은  다른  사람의  코인이  트랜잭션에  사용되는  것을  막기  위한  것이다.  위  절차를  실제  비트코인  지불과정에 적용하면  다음과  같다. Alice 가  Bob 에게  11.7 BTC 를  보내고  싶다고  가정하자.  먼저  Alice  지갑주소로부터  표시된 금액의  합이  적어도  11.7 BTC  이상인  UTXO 의  집합을  찾는다.  실제  대부분의  경우에는  11.7 BTC 를  정확히  바로 선택할  수  없다. Alice 의  지갑주소에서  각각  6, 4, 2 BTC  가  표시된  3 개의  UTXO 를  참조할  수  있다고  하자.  이 3 개의  UTXO 가  트랜잭션의  input 이  되고  2 개의  output 이  생성된다. Output  중  하나는  11.7 BTC 가  표시된  새로운 UTXO 이며  소유자는  Bob 의  지갑주소가  된다.  그리고  다른  하나는  12(6+4+2) - 11.7 = 0.3 BTC 의 &ldquo;잔돈(change)&ldquo;이  표시된  새로운  UTXO 이며  소유자는  Alice  자신의  지갑주소가  된다.</p>
</blockquote>
<p>상태변환시스템의 과정에 대해서 설명 하고 있다. 해당 과정은 은행에서의 입출금과 다를것이 없다.</p>
<ul>
<li><strong>UTXO</strong> 에는 각자의 <strong>코인금액</strong>과 그것을 소유하고 있는 <strong>공개키</strong>의 정보가 있다.</li>
<li><strong>트랜잭션</strong>의 <strong>입력</strong>은 <strong>송금자의 UTXO</strong> 에 대한 참조정보, 송금자의 private key 로 생성된 <strong>암호화된 서명</strong> 을 포함하고 <strong>출력</strong>으로는 상태에 추가된 <strong>새로운 UTXO</strong> 정보</li>
</ul>
<h3 id="채굴mining">채굴(Mining)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/ethereum-white-paper/%EC%B1%84%EA%B5%B4.png"
        data-srcset="/images/ethereum-white-paper/%EC%B1%84%EA%B5%B4.png, /images/ethereum-white-paper/%EC%B1%84%EA%B5%B4.png 1.5x, /images/ethereum-white-paper/%EC%B1%84%EA%B5%B4.png 2x"
        data-sizes="auto"
        alt="/images/ethereum-white-paper/%EC%B1%84%EA%B5%B4.png"
        title="/images/ethereum-white-paper/%EC%B1%84%EA%B5%B4.png" width="1722" height="498" /></p>
<blockquote>
<p>만일  우리가  위에서  기술한  내용을  신뢰를  기반으로  하는  중앙집권화된  서비스  방식으로  구현하자면  매우  간단한 일이  될텐데,  왜냐하면  중앙  서버  하드드라이브에  상태변화의  과정을  저장만  하면  되기  때문이다.    그러나 비트코인에서는,  탈중앙화된  통화시스템을  구축하고자  하는  것이며,  이를  위해서는    모든  사람이  수긍할  수  있는 트랜잭션  순서  합의  시스템을  상태변화시스템과  결합해야만  한다.  <strong>비트코인의  분산  합의  과정은  네트워크에 &ldquo;블록(blocks)&ldquo;이라  불리는  트랜잭션  패키지를  계속적으로  생성하고자  시도하는  노드들을  필요로  한다.  이  네트워크는 약  10 분마다  하나의  블록을  생성하도록  계획되어  있고  각  블록은  타임스탬프,  논스(nonce),  이전  블록에  대한 참조(이전  블록의  해시),  그리고  이전  블록  이후에  발생한  모든  트랜잭션의  목록을  포함한다.  이  과정을  통해서 지속적으로  성장하는  블록체인이  생성되게  되는데,  비트코인  장부의  최신상태(state)를  나타내기  위해  지속적인 업데이트가  이루어진다.</strong></p>
</blockquote>
<blockquote>
<p>이  체계에서  하나의  블록이  유효한지  아닌지를  확인하기  위한  알고리즘은  다음과  같다.</p>
<ol>
<li>이  블록에  의해  참조되는  <strong>이전  블록이  존재하는지,  유효한지  확인한다.</strong></li>
<li><strong>타임스탬프  값이  이전  블록의  타임스탬프  값보다  크면서  2 시간  이내인</strong>지  확인한다.</li>
<li><strong>작업증명(proof of work)이  유효한지  확인한다</strong>.</li>
<li><strong><code>S[0]</code>를  이전  블록의  마지막  상태(state)가  되도록  설정</strong>한다.</li>
<li><code>TX</code>를  <code>n</code>개의  트랜잭션을  가지는,  블록의  트랜잭션  목록으로  가정한다.  폐구간  <code>0...n-1</code>의  모든  i 에  대해, <strong><code>S[i+1] = APPLY(S[i], TX[i])</code>집합</strong>  중  어느  하나라도  에러를  리턴하면  거짓(false)을  리턴하며  종료한다.</li>
<li><strong>참(true)을  리턴하고, <code>S[n]</code>를  이  블록의  마지막  상태로  등록</strong>한다</li>
</ol>
</blockquote>
<blockquote>
<p>기본적으로  블록의  각  트랜잭션은  유효한  상태변환을  일으켜야  한다.  <strong>여기서  상태가  블록  내에  어떠한  방법으로로 기록되지  않았다는  점에  주목해보자.</strong>  상태는  유효성을  검증하는  노드가    매번  계산해서  기억해야  할    완전히  추상적 것(abstraction)인데,  이것은    <strong>원시상태(genesis state)부터  해당  블록까지의  모든  트랜잭션을  순차적으로  적용함으로써 계산될  수  있다.</strong>  채굴자가  블록에  포함시키는  트랜잭션의  순서에  주목해보자.  만약  어떤  블록에  A 와  B 라는  두 트랜잭션이  있고  B 가  A 의  출력  UTXO 를  소비한다고  하자.  이때  A 가  B 이전의  트랜잭션인  경우  그  블록은 유효하지만,  그렇지  않을  경우  유효하지  않다.</p>
</blockquote>
<p>상태는 블록 내에 기록되지 않고 노드가 매번 원시상태(체인의 가장 첫번째 블록) 부터 끝가지 모두 적용함으로서 현재 상태를 얻어 낼 수 있다.</p>
<blockquote>
<p>블록  유효성  검증  알고리즘에서  특징적인  부분은  <strong>&ldquo;작업증명(proof of work)&ldquo;의  조건</strong>  즉, 256  비트의  숫자로  표현되는 각  블록의  이중-SHA256  해시값이  동적으로  조정되는  <strong>목표값(이더리움  영문  백서를  작성하는  시점에서  대략  2192)보다 반드시  작아야  된다는  조건이다.</strong>  작업증명의  목적은  블록  생성을  계산적으로  어렵게  만들어서  sybil  공격자들이 마음대로  전체  블록체인을  조작하는  것을  방지하는  것이다. SHA256 은  전혀  예측불가능한  유사난수 함수(pseudorandom function)로  설계되었기  때문에  유효  블록을  생성하기  위한  유일한  방법은  블록헤더의 <strong>논스(nonce)  값을  계속해서  증가시키면서,  생성되는  새로운  해시값이  위의  조건을  만족하는지  확인하는  과정을 반복하는  것뿐이다.</strong></p>
</blockquote>
<p>작업증명을 하는 방식은 SHA256 로 설계 되어 있기 때문에 어떠한 방법으로도 목표값을 찾는 계산을 단축 시킬 수 없다. -&gt; 알고리즘을 조정해서 목표값을 찾기위한 CPU 전력이나 시간을 줄일 수 없다.<!-- raw HTML omitted -->  <strong>즉 목표값을 찾으려면 모든 CPU 는 비슷한 수준의 계산(반복) 을 해야한다.</strong></p>
<blockquote>
<p>현재  목표값인  2192 하에서  하나의  유효블록을  발견하기  위해서  평균적으로  264 번의  시도를  해야만  한다.  일반적으로 이  목표값은  매  2016 개의  블록마다  네트워크에  의해  재조정되어서  네트워크의  현재  노드들이  평균적으로  10 분마다 새로운  블록을  생성할  수  있도록  한다.  <strong>이러한  연산작업에  대한  보상으로  현  시점의  각  블록의  채굴자들은  25 BTC 를 획득할  자격을  가진다.</strong>  그리고  출력금액보다  입력금액이  큰  트랜잭션이  있다면  그  차액을  <strong>&ldquo;트랜잭션 수수료(transaction fee)&ldquo;로  얻는다.</strong>  이것이  BTC 가  발행되는  유일한  방법이며,  원시상태(genesis state)에는  아무런 코인이  포함되지  않았다.</p>
</blockquote>
<p>블록을 형성하는 연산작업을 한것에 대한 대가로 25BTC를 발행해서 제공한다.</p>
<blockquote>
<p>채굴  목적을  더  잘  이해하기  위해서,  악의적인  공격자가  있을  때  어떤  일이  발생하는지  알아보자.  비트코인  기저를 이루는  암호기법은  안전한  것으로  알려져  있다.  그러므로  공격자는  비트코인  시스템에서  암호기법에  의해  직접 보호되지  않는  부분인  ‘트랜잭션  순서’를  공격  목표로  잡을  것이다.  공격자의  전략은  매우  단순하다.</p>
<ol>
<li>어떤  상품(가급적이면  바로  전달되는  디지털  상품)을  구매하기  위해  판매자에게  100 BTC 를  지불한다.</li>
<li>상품이  전송되기를  기다린다.</li>
<li>판매자에게  지불한  것과  같은  100 BTC 를  공격자  자신에게  보내는  트랜잭션을  생성한다.(이중지불  시도)</li>
<li>비트코인  네트워크가,  공격자  자신에게  보내는  트랜잭션이  판매자에게  지불하는  트랜잭션보다  먼저  수행된   것으로  인식하도록  한다.</li>
</ol>
</blockquote>
<blockquote>
<p>1 번  과정이  발생하고  몇  분  후에  몇몇  채굴자가  그  트랜잭션을  블록에  포함할  것이다.  이  블록  번호를  270000 이라 하자.  대략  1 시간  후에는  이  블록  다음의  체인에  5 개의  블록들이  추가될  것이다.  이  5 개의  블록들은  위  1 번 트랜잭션을  간접적으로  가리킴으로써  &ldquo;컨펌(confirming)&ldquo;한다.  이  시점에서  판매자는  지불이  완료된  것으로  판단하고 상품을  전송할  것이다.  디지털  상품으로  가정했으므로  전송은  바로  끝난다.  이제  공격자는  판매자에게  보낸  것과 동일한  100 BTC 를  공격자  자신에게  보내는  다른  트랜잭션을  생성한다.  만약  공격자가  그냥  단순하게  트랜잭션을 시도한다면,  채굴자들이  <code>APPLY(S,TX)</code>를  실행하고  이  <code>TX</code>는  상태에  더  이상  존재하지  않는  UTXO 를  소비하려 한다는  것을  알아차리므로  이  트랜잭션은  진행되지  않는다.  그러므로  대신에,  같은  부모  블록  269999 을  가리키지만 판매자에게  보낸  것을  대체하는  새로운  트랜잭션이  포함된  다른  버전의  블록  270000 을  채굴함으로서  블록체인 &ldquo;분기점(fork)&ldquo;을  생성한다.  이  블록  정보는  원래  것과  다르므로  작업증명(proof of work)이  다시  수행되어야  한다. 그리고  공격자의  새버전  블록  270000 은  기존  270000 과  다른  해시를  가지므로  원래  블록  270001 부터  270005 는
공격자의  블록을  가리키지  않는다.  그러므로  <strong>원래  체인과  공격자의  새로운  체인은  완전히  분리된다.</strong>  이러한 분기점에서  비트코인  <strong>네트워크의  규칙은  가장  긴  블록체인을  참으로  인식하는  것이다.</strong>  공격자가  자신의  체인에서  <strong>혼자 작업</strong>을  하는  동안  정당한  채굴자들은  원래의  270005 체인에서  작업할  것이기  때문에  <strong>공격자  자신의  체인을  가장  길게 만들기  위해서는  네트워크의  다른  노드들의  계산능력  조합보다  더  큰  계산능력을  가져야  한다.(이를  51% attack 이라 한다.)</strong></p>
</blockquote>
<p>공격자가 이중지불로 상대를 속이려면 정직한 거래를 먼저 끝낸 후에 자기자신에게 해당 BTC를 보내는 거래를 만든다. 이 과정에서 모든 블록들은 전 블록들과 연결되어 있기 때문에 두개의 거래는 체인이 완전히 분리된다. <strong>네트워크는 가장 긴 블록체인을 참으로 인식하기 때문에 공격자는 혼자서 다른 모든 정직한 노드들보다 빠르고 길게 체인을 만들어야한다.</strong></p>
<h3 id="머클트리merkle-trees">머클트리(Merkle Trees)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png"
        data-srcset="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png, /images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png 1.5x, /images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png 2x"
        data-sizes="auto"
        alt="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png"
        title="/images/ethereum-white-paper/%EB%A8%B8%ED%81%B4%ED%8A%B8%EB%A6%AC.png" width="988" height="606" /></p>
<blockquote>
<p><em>Merkle tree(머클트리)의 몇몇 노드만 보아도 곁가지(branch)의 유효성을 입증하기에 충분하다.</em><!-- raw HTML omitted --> <em>Merkle tree의 어떤 부분을 바꾸려는 시도는 결국 상위 해시값 어딘가에 불일치를 만든다.</em></p>
</blockquote>
<blockquote>
<p>비트코인의  중요한  확장  기능은  블록이  여러  계층  구조(multi-layer data structure)에  저장된다는  것이다.  <strong>어떤 블록의  &ldquo;해시(hash)&ldquo;란  사실  블록헤더의  해시만을  의미한다.</strong>  이  블록헤더에는  <strong>타임스탬프,  논스(nonce),  이전  블록 해시,  그리고  블록에  포함된  모든  트랜잭션  정보에  의해  생성되는  <!-- raw HTML omitted -->Merkle tree 의  루트  해시가  들어있는  200  바이트 정도의  데이터이다.<!-- raw HTML omitted --></strong>  머클트리(Merkle tree)는  이진트리(binary tree)의  일종으로서  트리의  최하위에  위치하고  기저 데이터가  들어있는  수  많은  잎노드,  자기  자신  바로  하위에  있는  두  자식  노드의  해시로  구성된  중간  노드,  자기  자신 바로  하위에  있는  두  자식  중간노드의  해시로  구성된  트리의  &ldquo;최상위(top)&ldquo;에  있는  하나의  루트  노드의  집합이다. <strong>머클트리(Merkle tree)의  목적은  어떤  블록의  데이터가  분리돼서  전달될  수  있도록  하는  것이다.</strong>  만약에  비트코인의 어떤  노드가  한  소스로부터  <strong>블록헤더만을  다운로드  받고,  이  블록헤더와  관계된  트랜잭션  정보는  다른  소스로부터 다운받아도  이  데이터들이  여전히  정확하다는  것이  보장된다.</strong>  이것이  가능한  이유는  머클트리(Merkle tree)에서  <strong>하위 노드들의  해시값이  상위  노드에  영향을  주기  때문에  어떤  악의적인  유저가  머클트리  최하위에  있는  트랜잭션  정보를 가짜로  바꿔치기  하면  상위  부모들의  해시값들이  변해서  결국  트리의  루트값이  바뀌므로,  결과적으로  이  블록의 해시가  달라지기  때문이다.</strong>  이렇게  되면  이  블록은  완전히  다른  블록으로  인식되게  되며,  이것은  유효하지  않은 작업증명을  가지고  있게  될  것이  확실시된다.</p>
</blockquote>
<blockquote>
<p><strong>머클트리  프로토콜은  비트코인  네트워크를  장기간  지속가능하게  만드는  기초가  된다.</strong>  비트코인  네트워크에서  <strong>각 블록의  모든  정보를  저장하고  처리하는  &ldquo;완전노드(full node)&ldquo;는</strong>  2014 년  4 월  기준으로  거의  15 GB 의  디스크  공간을 필요로  하며  매달  1 GB  넘게  증가하고  있다.  현재  데스크탑  컴퓨터  정도에서는  수용할  수  있지만  스마트폰에서는 불가능하다.  그리고  나중에는    소수의  사업체들이나  풀  노드를  유지할  수  있을  것이다.  반면  &ldquo;단순화된 지불확인(simplified payment verification, SPV)&ldquo;으로  알려진  프로토콜은  &ldquo;가벼운  노드(light node)&ldquo;라고  불리는  또 다른  형태의  노드를  가능하게  해준다.  <strong>가벼운  노드는  블록헤더를  다운로드하고  그  블록헤더에서  작업증명을  검증한다. 그리고  관련  트랜잭션들에  대한  &ldquo;곁가지들(branches)&ldquo;만을  다운로드  한다.</strong>  이렇게  전체  블록체인의  매우  작은 비율만을  다운로드  함에도  불구하고  강한  안전성을  보장하면서도,  임의의  트랜잭션의  상태  및  잔고  상태를  알아낼  수 있게  한다.</p>
</blockquote>
<h3 id="블록체인--기술을--이용한--다른--응용--사례--alternative-blockchain-applications">블록체인  기술을  이용한  다른  응용  사례  (Alternative Blockchain Applications)</h3>
<blockquote>
<p>블록체인의  근본  아이디어를  확장해  다른  개념으로  응용하려는  아이디어  역시  오랜  역사를  가지고  있다. 2005 년 ‘Nick Szabo’)는  <strong>&ldquo;소유주  권한을  통한  재산권  보장&quot;이라는  글을  발표했다.</strong>  그는  정주(homesteading),  불법점유, 지공주의(Georgism)  등의  개념을  포함한  정교한  틀을  설계해  누가  어떤  땅을  가지고  있느냐라는  <strong>등기  문제를 블록체인  기반  시스템으로  처리할  수  있음을  보였다.</strong> 그는  이것이  &ldquo;데이터베이스  복제  기술의  새로운  발전&quot;덕분에 가능해졌다고  말했다.  하지만,  불행히도  그  당시에는  쓸만한  효과적인  파일  복제  시스템이  없었다.  그래서  Nick Szabo 의  프로토콜은  실현되지  못했다.  하지만  2009 년  이후,  비트코인  분권  합의  시스템이  발전하면서,  수  많은  대안 응용  사례가  빠르게  부각되기  시작했다</p>
</blockquote>
<blockquote>
<p>*네임코인  - 2010 년에  만들어진  <strong>네임코인은  &lsquo;탈중앙화된  명칭  등록  데이터베이스&rsquo;라고  부르는  것이  가장  좋을  것이다.</strong> 토르,  비트코인,  비트메시지와  같은  탈중앙화된  자율조직  프로토콜을  이용할  때,  사용자는  타인과  서로  교류하기  위해 각자의  계정을  구분해내야  한다.  하지만  현존하는  가능한  구별  방법은 1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy 와  같은  식의  의사난수  해쉬를  이용하는  방식이었다.  이상적으로는, 사용자가  &ldquo;george&quot;같은  일상적인  이름을  계정  이름으로  갖는  것이  좋을  것이다.  하지만  이  때  문제는  어떤  사용자가 &ldquo;george&rdquo;  라는  이름을  계정을  만들수  있다면,  다른  누구도  똑같이  &ldquo;george&quot;라는  계정을  등록해  흉내낼  수  있다는 점이다.  <strong>유일한  해답은  선출원주의로,  먼저  등록한  사람이  성공하고  두  번째  등록한  사람은  실패하도록  하는  것이다</strong>. 이는  이미  비트코인  합의  규약에  완벽히  적용된  문제이기도  하다.  네임코인은  이런  아이디어를  응용한  가장  오래되고 가장  성공적인  명칭  등록  시스템이다.</p>
</blockquote>
<p>각자의 계정을 구분하기 위해서 블록체인 시스템을 이용.<!-- raw HTML omitted -->
네임코인 - 계정이름을 블록체인 시스템에 등록해서 겹치는 계정이름이 없도록 하는 명칭 등록 시스템</p>
<blockquote>
<p>*컬러드  코인-  <strong>컬러드  코인의  목적은  누구나  비트코인  블록체인  위에서  자신만의  고유한  디지털  화폐를  발행할  수 있는  프로토콜  역할을  하는  것이다.</strong>  또는  (그  디지털  화폐의  발행량이  한  단위  밖에  없는  단순한  경우로  볼  수  있는) 자기  자신만의  디지털  토큰을  발행하는  프로토콜  역할을  하는  것이다.  컬러드  코인  프로토콜에서,  <strong>사용자는  특정 비트코인  UTXO 에  공개적으로  색깔을  부여함으로써  새  화폐를  &ldquo;발행&quot;할  수  있다.</strong>  다른  UTXO 의  색깔은  이미 소비된(혼합  색깔  입력의  경우에는  몇몇  특별한  규칙이  적용된다)  것으로  간주하는  거래의  입력과  같은  색깔이  되도록 재귀적으로  정의한다.  이  프로토콜은  블록체인을  처음부터  끝까지  역추적해  그들이받은  UTXO 의  색깔을  정함으로써, 사용자가  특정  색깔을  가진  UTXO 만  지갑에  간직하고  그  코인을  보통  비트코인처럼  여기저기  보낼  수  있게  한다.</p>
</blockquote>
<p>특정 비트코인 UTXO 에 색깔을 부여 -&gt; 거래의 입력 색깔과 같은 색깔의 UTXO 만 거래가 가능하도록 여긴다.<!-- raw HTML omitted -->
비트코인 위에 색깔을 적용함으로 새로운 화폐를 발행</p>
<blockquote>
<p>*메타코인-  메타코인이  품고  있는  아이디어는,  <strong>비트코인  거래를  메타코인  거래  저장에  이용하되,  상태  이동  함수 APPLY&rsquo;  를  다르게  가짐으로써,  비트코인  시스템  위에서  운영되는  프로토콜을  갖는  것이다.</strong>  메타코인 프로토콜만으로는  비트코인  블록체인  속에  무효  메타코인  거래가  나타나는  현상을  예방  수  없기  때문에,  규칙이  하나 더해진다.  즉  만약  <strong>APPLY&rsquo;(S, TX)가  에러를  리턴하면,  프로토콜은  APPLY&rsquo;(S,TX)=S 로  정해진다.</strong>    비트코인  스스로는 내부  실행이  불가능한,  잠재적으로  더  발전된  성질을  가진  무작위  암호화폐  프로토콜을  만드는  쉬운  메커니즘이라고 할  수  있다.  반면  이  프로토콜의  개발비용은  적은데  왜냐하면  채굴과  네트워킹의  복잡성  문제가  이미  비트코인 프로토콜에  의해  처리되고  있기  때문이다.</p>
</blockquote>
<blockquote>
<p><strong>일반적으로  합의  프로토콜을  건설하는  데  두  가지  접근방법이  있다.  하나는  독립적인  네트워크를  세우는  것이고  다른 하나는  비트코인  시스템과  연동되는  프로토콜을  세우는  것이다.</strong>  <strong>전자의  접근  방법</strong>은,  네임코인  같은  응용  사례에서는 상당히  성공적이었지만,  실제  실행하는  데  어려움이  있다;  <strong>각  개별  실행주체가  모든  필요한  상태변환과  네트워킹 코드를  건설하고  점검해야  할  뿐만  아니라  독립적인  블록체인을  구동시켜야  한다.  나아가,    분권  합의  기술에  관한 어플리케이션의  집합이  멱함수분포를  따를  것으로  예상된다.</strong>  즉,  대다수  어플리케이션은  자기  자신의  블록체인을 보장하기에는  너무  작을  것이다.    그리고  또  거대한  클래스의  분권화된  어플리케이션,  즉  서로  교류를  하기  위한 분권화된  자율  기구(DAO)가  생겨날  것이라고  예상한다.</p>
</blockquote>
<blockquote>
<p><strong>후자의  접근  방법,  즉,  비트코인에  기반한  접근  방법은  비트코인의  단순  지불  검증(SPV)특징을  물려받지  못한다는 단점이  있다.</strong>  단순지불검증은  비트코인에서는  작동한다.  왜냐하면  비트코인은  블록체인  깊이(depth)를  검증  대리 수단으로  이용할  수  있기  때문이다.  한  거래의  근원을  찾아  충분히  뒤로  돌아가보면,  그  상태의  정합성을  증명하는 부분이  있었다고  말해도  무방하다.  <strong>반면,  블록체인에  기반한  메타-프로토콜은  무효  거래가  블록체인에  포함되지 않도록  막을  방법이  자기  자신의  프로토콜  자체에는  없다.</strong>  그렇기  때문에  완전히  안전보장이  된  단순지불검증  메타- 프로토콜이라면,  어떤  거래가  유효한지  아닌지를  결정하기위해,  항상  비트코인  블록체인의  원점까지  돌아가  훑어보는 작업이  필요하다.  현재까지  비트코인에  기반한  메타-프로토콜의  모든  &ldquo;간단한&rdquo;(light)  클라이언트  구현은  자료를 제공하는  믿을  만한  서버에  의지하고  있는  형편이다.  우리가  암호화폐를  만든  가장  중요한  목적이  제 3 의  신용기구의 필요성을  없애는  것이었다는  걸  특히  되새겨본다면,  이것은  아주  분명하게도,  차선의  결과가  될  뿐이다.</p>
</blockquote>
<h3 id="스크립팅scripting">스크립팅(Scripting)</h3>
<blockquote>
<p><strong>별도의  확장없이도  비트코인  프로토콜은  낮은  수준의  &ldquo;스마트  계약&quot;의  개념을  가능하게  할  수  있다.</strong>  비트코인의 UTXO 는  공개키만으로  획득할  수  있을  뿐만  아니라,  <strong>단순  스택-기반  프로그래밍  언어로  표현되는  더  복잡한 스크립트로도  획득할  수  있다.  이런  경우에는, UTXO 를  지출하는  거래는  그  스크립트를  만족하는  데이터를 제공해야만  한다.</strong> 사실,  기초적인  공개키  소유권  메커니즘도  스크립트를  통해  실행된다:  그  스크립트는  타원곡선서명을 ‘입력’으로  받아  그  거래와  UTXO 를  가진  주소에  대해  검증을  하고  만약  검증이  성공하면  1 을,  실패하면  0 을 ‘출력’한다.  여러  다른  다양한  사용  사례에  대해  좀  더  복잡한  여러  스크립트들이  있을  수  있다.</p>
</blockquote>
<blockquote>
<p>예를  들어,  주어진  세  개의  개인  키  가운데  두  개로부터  서명을  받아야만  승인이  되도록  스크립트를  짤  수  있다.  이런 스크립트는  회사  계정,  보안  저축  계정,  상업  공탁  상황  등에  유용하게  쓰일  수  있다.  스크립트는  또한  어떤  계산 문제의  답에  대한  포상금을  지불하는데도  쓰일  수  있다. &ldquo;만약  당신이  이  액면가의  도기코인  거래를  나에게  보냈다는 SPV  증명을  제공한다면,  이  비트코인  UTXO 는  당신  것이다&quot;라는  식으로  말하는  스크립트를  짤  수도  있다.  즉 근본적으로  탈중앙화된  상호-암호화폐  교환을  가능하게  한다.</p>
</blockquote>
<blockquote>
<p>하지만  비트코인에  구현된  스크립트  언어는  몇가지  중요한  한계가  있다.</p>
<ul>
<li><strong>튜링불완전성:</strong>  비트코인  스크립트  언어로  할  수  있는  작업이  많긴  하지만,  모든  경우의  프로그래밍을  다 지원하지는  않는다.  특히 <strong>while 이나  for 와  같은  순환(loop)  명령  카테고리가  빠져  있다.</strong>  순환  명령어를  없앤 이유는  거래  증명을  할  때  무한  순환에  빠지는  것을  막기  위해서였다.  이론적으로는  이건  스크립트 프로그래머가  극복할  수  있는  장애물이기는  하다. .왜냐하면  어떤  순환  명령이든  단순히  하위  코드를  여러차례  if  구문과  함께  반복함으로써  구현이  가능하기  때문이다.  하지만  이것은  아주  공간  비효율적인 프로그램이  된다.  예를  들어  대안  타원곡선서명  알고리즘을  실행하려면  코드  안에  있는  곱셈을  모두 개별적으로  256 번  반복하는  것이  필요하다.</li>
<li><strong>가치  무지:</strong> <strong>UTXO  스크립트만으로는  인출  액수를  세밀하게  통제할  방법이  없다</strong>.  예를  들어,  신탁  계약의
강력한  실용  사례라  할수  있는  헷지  계약을  살펴보자. A 와  B 가  $1000 어치의  BTC 를  공동계좌에  입금했다고 하자.  시간이  지나면  비트코인의  가격이  오를  수가  있다.  두  사람은  30 일  후  자동으로  A  가  $1000 어치 BTC 를  받고  B 는  공동계좌의  나머지  잔액을  받는  그런  계약을  맺고  싶다.  하지만  이  계약은  1BTC 가  미국 달러로  얼마인지  정해줄  제 3 자를  필요로  한다.  만약  이런  계약이  실현가능하다면  지금  현존하는  완전 중앙집권적인  금융  시스템  아래에서도  고도로  발전된  계약  형태라고  볼  수  있다.  하지만  <strong>UTXO 는  인출액 전부가  송금되거나  말거나  밖에  선택할  수가  없다.</strong>  즉  세부  작은  단위로  나눠질  가능성을  포함할  수  없는 것이다.  위에  예를  든  계약  거래를  실행할  유일한  방법은  변하는  <strong>UTXO 의  액면가  단위를  아주  다양하게 양산하고(예를  들어  1 부터  30 까지의  모든  자연수  k 에  대해 2 의 k 승의  1 UTXO 를  만듦) A 가  B 에게 이중에서  필요한  금액에  맞는  것을  선택해서  보내게  하는  방식과  같이  매우  비효율적인  편법을  사용하는  길 뿐이다.</strong></li>
</ul>
</blockquote>
<p>비트코인의 거래방식이 매우 제한적이 된다. 거래해야하는 단위가 UTXO 가 가지고 있는 최소 단위 보다 작으면 거래가 불가능 하고 너무 크면 비효율적이다. 따라서 UTXO를 1달러 10달러 20 달러 이런식으로 모든 단위를 보유하고 있어야하는데 이것을 구성하는 것은 너무 비효율적 이다.</p>
<ul>
<li>
<p><strong>튜링완정성</strong> <!-- raw HTML omitted -->어떤 프로그래밍 언어나 추상 머신이 튜링 머신과 동일한 계산 능력으로 문제를 풀 수 있다는 것을 의미한다.</p>
</li>
<li>
<p><strong>튜링기계의 구성</strong><!-- raw HTML omitted -->
튜링 완전 언어 + 무한한 저장공간 = 모든 계산 가능한 문제를 계산하는 기계
= 튜링 기계(인간의 뇌)</p>
</li>
</ul>
<blockquote>
<ul>
<li><strong>상태표현제한:</strong> <strong>UTXO 가  표현할  수  있는  상태는  사용되었거나  안  되거나  둘  뿐이다</strong>.  그렇기  때문에  이  두가지 상태  이외에  다른  어떤  <strong>내부적  상태를  가지는  다중  단계  계약이나  스크립트를  만들  수가  없다.  이  점이  분산 환전  거래나  이중  암호  실행  프로토콜(계산  보상금을  보장하기  위해  필요하다)과  같은  다중  조건  계약을 어렵게  한다.</strong>  즉  UTXO 은  단순하고  1 회적인  계약에만  이용될  수  있을  뿐,  분산조직과  같은  더  복잡한 &ldquo;상태적(stateful)&rdquo;  계약에는  이용될  수  없고  메타프로토콜을  적용하기  어렵게  만든다.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>블록체인  무지(Blockchain-blindness)</strong>: <strong>UTXO 는  논스(Nonce),  타임스탬프,이전  블록해시같은  블록체인  자료를 해독하지  못한다.</strong>  이  단점으로  인해  스크랩트  언어  속에  잠재적으로  가치있을  무작위성이  빠지게  된다.  그래서 도박이나  여러  다른  분야의  어플리케이션을  만드는  데  한계를  보인다.</li>
</ul>
</blockquote>
<blockquote>
<p>정리하자면,  발전된  어플리케이션을  만드는  데  3 가지  접근법이  있다.  <strong>첫번째는  독립적인  블록체인을  만드는  것이고 두번째는  비트코인에  이미  내재된  스크립트를  이용하는  것이며,  세번째는  비트코인  상에서  작동되는  메타-규약을 건설하는  것이다.</strong>  독립적인  블록체을  쓰면  무한히  자유로운  프로그램을  짤  수  있지만  개발  기간,  초기  셋업  작업,  보안 등의  비용을  치뤄야  한다.  비트코인에  내재된  스크립트를  이용하면  실행이  간단하고  표준화된다는  장점이  있지만, 이용범위가  제한적이다.    메타규약을  쓰는  것은  간단하긴  하지만,  확장성의  결함을  감수해야  한다.</p>
</blockquote>
<blockquote>
<p><strong>이더리움을  통해  우리는  개발하기도  쉽고  더  강력한  라이트  클라이언트  기능을  가지는  동시에  경제적인  개발  환경과 블록체인  보안을  공유하는  어플리케이션을  만들  수  있는,  대안  프레임워크(alternative framework)를  건설하려고  한다.</strong></p>
</blockquote>
<h2 id="이더리움ethereum">이더리움(Ethereum)</h2>
<blockquote>
<p><strong>이더리움의  목적은  분산  어플리케이션  제작을  위한  대체  프로토콜을  만드는  것이다.</strong>  대규모  분산  어플리케이션에 유용할  것이라  생각되는  다른  종류의  제작기법을  제공하며,  빠른  개발  시간,  작고  드물게  사용되는  어플리케이션을 위한  보안,  다른  어플리케이션과의  효율적인  상호작용이  중요한  상황에  특히  주안점을  두고  있다.  이더리움은  튜링 완전  언어를  내장하고  있는  블록체인이라는  필수적이고  근본적인  기반을  제공함으로써  이  목적을  이루고자  한다. <strong>누구든지  이  언어를  사용하여  스마트  컨트랙트,  분산  어플리케이션을  작성하여  소유권에  대한  임의의  규칙,  트랜잭션 형식(transaction format),  상태변환  함수(state transition function)  등을  생성  할  수  있다.</strong>  네임코인의  기본적인 형태는  두  줄  정도의  코드로  작성할  수  있고,  통화나  평판  시스템  관련  프로토콜은  스무  줄  내외의  코드로  만들  수있다.  <strong>어떤  값을  저장하고,  특정한  조건들을  만족했을때만  그  값을  얻을  수  있게  하는  일종의  암호  상자인  스마트 컨트랙트  또한  이  플랫폼  위에  만들  수  있다.</strong>  이것은  비트코인의  스크립팅(scripting)이  제공하는  것보다  훨씬  강력한 기능들이  제공되기  때문에  가능한  것으로,  튜링-완전(Turing-completeness),  가치  인지능력(value-awareness), 블록체인  인지능력(blockchain-awareness),  상태(state)개념  등이  포함된다.</p>
</blockquote>
<p>이더리움은 블록체인의 스크립팅 보다 튜링 완전 언어를 내장하고 있어서 더 다양한 기능을 수행할 수 있다.</p>
<p><strong>이더리움과 비트코인의 가장 큰 차이점은 이더리움은 튜링불완전성을 해결할 수 있다는 것이고 비트코인은 그렇지 못하다는 것이다.</strong></p>
<h3 id="이더리움--어카운트ethereum-accounts">이더리움  어카운트(Ethereum Accounts)</h3>
<blockquote>
<p><strong>이더리움에서,  상태(state)는  어카운트(account)라고  하는  오브젝트(object)들로  구성되어  있다.</strong>  각각의  어카운트는 20 바이트의  주소와  어카운트  간  값과  정보를  직접적으로  전달해  주는  상태변환(state transition)을  가지고  있다. 이더리움  어카운트는  다음  네  개의  필드를  가지고  있다.</p>
<ul>
<li>논스(nonce):    각  트랜잭션이  오직  한번만  처리되게  하는  일종의  카운터</li>
<li>어카운트의  현재  이더(ether)  잔고</li>
<li>어카운트의  계약  코드  (존재한다면)</li>
<li>어카운트의  저장  공간  (초기설정(default)  상에서는  비어있음)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>이더는  이더리움의  기본  내부  암호-연료(crypto-fuel)</strong>  이고,  트랜잭션  수수료를  지불하는데  사용된다.  보통  두가지 종류의  어카운트가  존재하는데,  <strong>프라이빗  키에  의해  통제되는  외부  소유  어카운트(Externally Owned Accounts)  와 컨트랙트  코드에  의해  통제되는  컨트랙트  어카운트</strong>(Contract Accounts)가  있다.  외부  소유  어카운트는  아무런  코드도 가지고  있지  않으며,  이  어카운트에서  메시지를  보내기  위해서는  새로운  트랜잭션을  하나  만들고,  서명(signing)을 해야  한다.  <strong>컨트랙트  어카운트는  메시지를  받을  때마다,  자신의  코드를  활성화시키고,  이에  따라  메시지를  읽거나  내부 저장공간에  기록하고,  다른  메시지들을  보내거나,  컨트랙트들을  차례로  생성하게  된다.</strong></p>
</blockquote>
<blockquote>
<p>이더리움에서  <strong>컨트랙트는,</strong>  수행되거나  컴파일  되어야  할  어떤  것이라기  보다는,  이더리움의  실행  환경안에  살아있는 일종의  <strong>자율  에이전트(autonomous agents)로서,  메시지나  트랜잭션이  도착하면  항상  특정한  코드를  실행하고,  자신의 이더  잔고와,  영속적인  변수들을  추적하기  위해  자신의  키/값  저장소를  직접적으로  통제하는  역할을  한다.</strong></p>
</blockquote>
<p>이더 - 이더리움의 기본 내부 암호-연료</p>
<p>외부 소유 어카운트 - 프라이빗 키에 의해 통제된다. 어떤코드도 없고 트랜잭션과 서명으로 이루어져 있다.</p>
<p>컨트렉트 - 자율에이전트 로서, 항상 특정한 코드 실행, 변수 추가 등 자신의 저장소를 직접적으로 통제</p>
<h3 id="메시지와--트랜잭션messages-and-transactions">메시지와  트랜잭션(Messages and Transactions)</h3>
<blockquote>
<p>이더리움에서  사용되는  <strong>트랜잭션(transaction)이란</strong>  용어는  외부  소유  어카운트가  보낼  <strong>메시지를  가지고  있는  서명된 데이터  패키지를  말한다.</strong>  이  트랜잭션은  다음을  포함하고  있다.</p>
</blockquote>
<blockquote>
<ul>
<li>메시지  수신처</li>
<li>발신처를  확인할  수  있는  서명</li>
<li>발신처가  수신처로  보내는  이더의  양</li>
<li>선택적(optional)  데이터  필드</li>
<li>STARTGAS  값,  트랜잭션  실행이  수행되도록  허용된  최대  계산  단계수</li>
<li>GASPRICE  값,  매  계산단계마다  발신처가  지불하는  수수료</li>
</ul>
</blockquote>
<blockquote>
<p>처음  세  항목은  암호  화폐에서는  거의  표준처럼  사용되는  값이다.  데이터  필드는  초기값으로  설정된  기능(function)은 가지고  있지  않지만,  <strong>버추얼  머신(virtual machine)은  컨트랙트가  이  데이터에  접근할  때  사용할  수행코드(opcode)를 가지고  있다.</strong>  예를  들어,  블록체인  위에  도메인  등록  서비스로  기능하고  있는  컨트랙트가  있을  경우,  이  컨트랙트로 보내지는  데이터는  두개의  필드를  가지고  있는  것으로  해석할  수  있다.  첫번째  필드는  등록하고자  하는  도메인이고, 두번째  필드는  IP  주소이다.  <strong>컨트랙트는  메시지  데이터로부터  이  값들을  읽어서  저장소  내  적당한  위치에  저장한다.</strong></p>
</blockquote>
<p>암호 화폐에서 거래에 포함되는 3번째 까지는 표준적인 값들이다. 컨트렉트는 선택적 데이터 필드인 (예를 들어서) 도메인 과 IP 주소를 읽어서 특정 코드를 실행해 적당한 위치에 저장한다.</p>
<blockquote>
<p>STARTGAS  와  GASPRICE  필드는  이더리움의  <strong>앤티-서비스거부(anti-DoS)  모델</strong>에  있어서  매우  중요한  역할을  한다. 코드내의  우연적이거나  악의적인  무한루프,  또는  계산  낭비를  방지하기  위해  각각의  트랜잭션은  사용할  수  있는  <strong>코드 실행의  계산  단계  수를  제한</strong>하도록  설정되어야  한다.  계산의  기본  단위는  gas  이고  보통,  계산  단계는  1 gas  의 비용이  소요되나,  어떤  연산은  더  비싼  계산  비용을  치루거나,  상태의  일부분으로  저장되어야  하는  데이터의  양이 많을  경우  더  많은  수의  gas  비용이  필요하게  된다.  <strong>또한  트랜잭션  데이터에  있는  모든  바이트는  바이트당  5 gas  의 수수료가  든다.</strong>  이러한  수수료  시스템의  의도는  어떤  공격자가  계산,  밴드위스,  저장소  등을  포함하여  그들이  소비하는 모든  리소스에  비례하여  강제로  수수료를  지불하게  하는데  있다.  따라서,  따라서  이런  리소스중  어떤  것이라도 상당량을  소비하는  네트웍과  연관된  트랜잭션은  대략  증가분에  비례한  gas  수수료를  가지고  있어야  한다.</p>
</blockquote>
<p>앤티-서비스 거부 모델</p>
<ul>
<li>STARTGAS - 코드 실행의 계산 단계 수를 제한 함으로 무한루프, 계산 낭비를 방지한다.</li>
<li>GASPRICE - 리소스를 소비하는 양에 비례해서 수수료를 부과</li>
</ul>
<p>-&gt; Dos attack 으로부터 어느정도의 안전을 확보 할 수 있다.</p>
<p>Dos attack - 시스템을 악의적으로 공격해 <strong>해당 시스템의 리소스를 부족하게 하여</strong> 원래 의도된 용도로 사용하지 못하게 하는 공격이다</p>
<h3 id="메시지messages">메시지(Messages)</h3>
<blockquote>
<p>컨트랙트는  다른  컨트랙트에게  “메시지”를  전달할  수  있다.  메시지는  따로  저장될  필요가  없는  이더리움의  실행 환경에서만  존재하는  가상의  오브젝트이다.  메시지는  다음의  것을  포함하고  있다.</p>
<ul>
<li>(암묵적으로)  메시지  발신처</li>
<li>메시지  수신처</li>
<li>메시지와  함께  전달되는  이더</li>
<li>선택적  데이터  필드</li>
<li>STARTGAS  값</li>
</ul>
</blockquote>
<blockquote>
<p>본질적으로,  메시지는  외부  실행자가  아닌  컨트랙트에  의해  생성된다는  것을  제외하면  트랜잭션과  유사하다.  현재 코드  수행을  하고  있는  컨트랙트가  메시지를  생성하고  실행하라는  CALL opcode 를  만나게  되면  메시지를  생성한다. 트랜잭션과  마찬가지로,  메시지는  해당  코드를  실행하는  수신자  어카운트에  도달하게  된다.  따라서,  <strong>컨트랙트는  외부 실행자가  하는  것과  정확히  같은  방식으로  다른  컨트랙트와  관계를  맺을  수  있다.</strong></p>
</blockquote>
<blockquote>
<p>트랜잭션이나  컨트랙트에  의해  할당된  gas  허용치는  그  트랜잭션과  모든  하위  실행에  의해  소모된  총  gas  에 적용된다.  예를  들어,  외부  실행자  A  가  B  에게  1000gas 와  함께  트랜잭션을  보내고, B  는  600 gas  를  소모한  뒤  C 에게  메시지를  보내고, C 의  내부  실행에  300 gas 를  소모한  후  반환하면, B  는  gas  가  모두  소모되기  전에  100 gas 를  더  사용할  수  있다.</p>
</blockquote>
<p>이더리움 메세지 - 비트코인의 트랜잭션 의 차이점</p>
<ul>
<li>컨트랙트에 의해 생성 된다 - 트랜잭션은 외부 실행자로 부터 생성 된다</li>
<li>데이터를 포함 할 수 있는 선택지</li>
<li>메시지를 받는 자가 contract account 이면 응답을 리턴 할 수 있다. (함수 처럼 작용)</li>
</ul>
<p>컨트랙트에 의해서 메세지를 생성할 수 있게 함으로서 다양한 기능을 수행 할수 있게 한다.</p>
<ul>
<li>이러한 기능을 이용해서 <strong>스마트 컨트렉트</strong> 라는 것을 만드는 것 같다. 컨트렉트에 메세지로  <strong>해당 거래에 다양한 역할을 부여</strong>할 수 있도록 코딩이 가능하게 하는 것으로 이해했다</li>
<li>비트코인 같은 경우에는 매우 간단한 돈을 주고 받는 기능 밖에 수행하지 못한다.</li>
<li>비트코인은 단순하게 돈으로서의 역할만 했지만 이더리움은 그 이상의 것도 가능하다.</li>
</ul>
<p>gas 수수료 -</p>
<h3 id="이더리움--상태--변환--함수ethereum-state-transition-function">이더리움  상태  변환  함수(Ethereum State Transition Function)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/ethereum-white-paper/%EC%83%81%ED%83%9C%EB%B3%80%ED%99%98%ED%95%A8%EC%88%98.png"
        data-srcset="/images/ethereum-white-paper/%EC%83%81%ED%83%9C%EB%B3%80%ED%99%98%ED%95%A8%EC%88%98.png, /images/ethereum-white-paper/%EC%83%81%ED%83%9C%EB%B3%80%ED%99%98%ED%95%A8%EC%88%98.png 1.5x, /images/ethereum-white-paper/%EC%83%81%ED%83%9C%EB%B3%80%ED%99%98%ED%95%A8%EC%88%98.png 2x"
        data-sizes="auto"
        alt="/images/ethereum-white-paper/%EC%83%81%ED%83%9C%EB%B3%80%ED%99%98%ED%95%A8%EC%88%98.png"
        title="title" width="1800" height="841" /></p>
<blockquote>
<p>이더리움  상태  전이  함수  APPLY(S, TX) -&gt; S’  은  다음처럼  정의  될  수  있다.</p>
</blockquote>
<blockquote>
<ol>
<li>트랜잭션이  형식에  제대로  맞는지(즉,  올바른  개수의  값을  가지고  있는지)  체크하고,  서명이  유효한지,  논스가 발신처  어카운트의  논스와  일치하는지를  체크한다.  그렇지  않다면  오류를  반환한다.</li>
<li>STARTGAS * GASPRICE  로  트랜잭션  수수료를  계산하고,  서명으로부터  발신처주소를  결정한다.  발신처 어카운트  잔고에서  이  수수료를  빼고  발신자  논스를  증가시킨다.  발신처  잔고가  충분하지  않으면  오류를 반환한다.</li>
<li>GAS = STARTGAS  로  초기화  한후,  트랜잭션에서  사용된  바이트에  대한  값을  지불하기  위해  바이트당  gas 의특정양을  차감한다.</li>
<li>발신처  어카운트에서  수신처  어카운트로  트랜잭션  값을  보낸다.  수신처  어카운트가  존재하지  않으면  새로 생성한다.  <strong>수신처  어카운트가  컨트랙트이면,  컨트랙트의  코드를  끝까지  또는  gas  가  모두  소모될  때  까지 수행한다.</strong></li>
<li>발신처가  충분한  ‘돈&rsquo;을  가지고  있지  못해서  값  전송이  실패하거나,  코드  수행시  gas 가  부족하면,  모든  상태 변경을  원상태로  돌려놓는다.  단,  수수료  지불은  제외되고,  이  수수료는  채굴자  어카운트에  더해지게  된다.</li>
<li>그  외에는,  모든  남아있는  모든  gas  에  대한  수수료를  발신처에게  돌려주고,  소모된  gas  에  지불된  수수료를 채굴자에게  보낸다.</li>
</ol>
</blockquote>
<blockquote>
<p>예를  들어,  다음과  같은  컨트랙트  코드를  가정  해  보자.</p>
</blockquote>
<blockquote>
<p><code>if !self.storage[calldataload(0)]:</code> <!-- raw HTML omitted -->
<code>self.storage[calldataload(0)] = calldataload(32)</code></p>
</blockquote>
<blockquote>
<p>실제로  컨트랙트  코드는  로우-레벨  EVM  코드로  작성되나,  이  예제는  이해하기  쉽게  하기  위해,  이더리움  하이-레벨 언어중  하나인  Serpent  로  작성하였다.  이  코드는  EVM  코드로  컴파일  될  수  있다.  컨트랙트의  스토리지는 비어있다고  가정하고,  트랜잭션이  10 ether, 2000 gas, 0.001ether gasprice, 64  바이트의  데이터(0-31  바이트까지는 숫자  2 를  나타내고, 32-63  바이트는  CHARLIE  라는  문자열)를  보낸다고  가정하자.  이  경우  상태  변환  함수의 프로세스는  다음과  같다.</p>
</blockquote>
<blockquote>
<ol>
<li>트랜잭션이  유효하고  형식에  제대로  맞는지  확인한다.</li>
<li>트랜잭션  발송처가  최소  2000 * 0.001=2 ether 를  가지고  있는지  확인하고,  그럴  경우,  발송처의  어카운트에서
2 ether 를  뺀다.</li>
<li>gas=2000 으로  초기화  한  후,  트랜잭션은  170 바이트  길이를  가지고,  바이트당  수수료는  5 라고  가정하면, 850 을  빼야  하고  결국  1150 gas  가  남게  된다.</li>
<li>송신처  어카운트에서  추가  10 ether 를  빼고  이것을  컨트랙트  어카운트에  더한다.</li>
<li>코드를  실행시킨다.  이  경우는  간단한데,  컨트랙트의  index 2 에  해당하는  스토리지가  사용되었는지  확인하고 (이  경우,  사용되지  않았다.) index 2 에  해당하는  스토리지  값을  ‘CHARLIE’로  설정한다.  이  작업에  187 gas 가  소비됐다고  가정하면,  남아있는  gas  의  양은  1150 - 187 = 963  이  된다.</li>
<li>963*0.001 = 0.963 ether 를  송신처의  어카운트로  되돌려주고,  결과  상태를  반환한다.</li>
</ol>
</blockquote>
<p>총 gas 수수료를 계산한뒤 각 트랜잭션을 수행하면서 gas 수수료를 차감한다. 수신처가 컨트랙트이면 코드를 실행하고 해당하는 수수료만큼 차감한다. 마지막 컨트랙트 코드를 수행하고 남은 gas 를 돌려준다.</p>
<blockquote>
<p>트랜잭션의 수신처에  컨트랙트가  없으면,  총  트랜잭션  수수료는  제공된  GASPRICE  와  트랜잭션의  바이트  수를  곱한 값과  같아지고,  트랜잭션과  함께  보내진  데이터는  관련이  없어지게  된다.</p>
</blockquote>
<blockquote>
<p><strong>메시지는  트랜잭션과  마찬가지  방식으로,  상태를  원래  상태로  되돌린다는  것에  주목하자.</strong>  메시지  실행  시  gas  가 부족하게  되면,  그  메시지  실행과  그  실행에  의해  촉발된  다른  모든  실행들은  원래대로  되돌려지게  되지만,  그  <strong>부모 실행은  되돌려질  필요가  없다.</strong>  이것은  컨트랙트가  다른  컨트랙트를  호출하는  것은  안전하다는  것을  의미한다. A  가  G gas 를  가지고  B 를  호출하면, A 의  실행은  최대  G    gas  만을  잃는다는  것을  보장받게  된다.  컨트랙트를  생성하는 CREATE  라는  opcode 를  보면,  실행  방식은  대체로  CALL  과  유사하나,  실행  결과는  새로  생성된  컨트랙트의  코드를 결정한다는  차이가  있다.</p>
</blockquote>
<p>코드가 잘못 되거나 수수료가 부족하더라도 부모 실행은 되돌려지지 않음으로 안전하다.</p>
<h3 id="코드--실행code-execution">코드  실행(Code Execution)</h3>
<blockquote>
<p>이더리움  컨트랙트를  구성하는  코드는  “이더리움  버추얼  머신  코드”  또는  “EVM  코드”로  불리는  로우-레벨,  스택 기반의  바이트코드  언어로  작성된다.  이  코드는  연속된  바이트로  구성되어  있고,  각각의  바이트는  연산(operation)을 나타낸다.  보통,  코드  실행은  0 부터  시작하는  현재  프로그램  카운터를  하나씩  증가시키면서  반복적으로  연산을 수행하도록  구성된  무한  루프이고,  코드의  마지막에  도달하거나  오류, STOP, RETURN  명령을  만나면  실행을  멈추게 된다.  연산을  수행하기  위해서는  데이터를  저장하는  세가지  타입의  공간에  접근할  수  있어야  한다.</p>
<ul>
<li>스택: last-in-first-out  컨테이너로  여기에  값들을  밀어  넣거나(push)  하거나  뺄(pop)  수  있다</li>
<li>메모리:  무한대로  확장  가능한  바이트  배열</li>
<li>컨트랙트의  영속적인(long-term)  저장소(storage):  키/값  저장소.  계산이  끝나면  리셋되는  스택이나
메모리와는  달리  저장소는  영속적으로  유지된다.</li>
</ul>
</blockquote>
<p>EVM 코드는 프로그램 카운터를 하나식 증가시키면서 연산을 수행하는 반복루프이다. <!-- raw HTML omitted -->
코드의 마지막, STOP, RETURN 명령을 만나면 멈춘다.</p>
<blockquote>
<p>코드는  또한  블록  헤더  데이터뿐만  아니라  특정  값이나,  발송자  및  수신되는  메시지의  데이터에  접근할  수  있고, 결과값으로  데이터의  바이트  배열을  반환할  수도  있다.</p>
</blockquote>
<blockquote>
<p>EVM  코드의  공식  실행  모델은  놀랍도록  단순하다.  이더리움  버추얼  머신이  실행되는  동안,  모든  계산  상태는 (block_state, transaction, message, code, memory, stack, pc, gas)  튜플(tuple)로  정의  될  수  있고, block_state  는 모든  어카운트를  포함하는  전역상태(global state)로서  잔고와  저장소(storage)를  포함한다.  반복되는  매  코드  실행 순간의  시작  시, code 의  pc(프로그램  카운터)번째  바이트의  현재  명령이  실행되고, ( pc  가  코드의  길이보다  크면(pc &gt;= len(code)) pc  는  0),  각각의  명령은  튜플을  어떻게  변화시킬지  대한  그  자신의  정의를  알고  있다.  예를  들어, ADD 는  스택에서  두  개의  아이템을  꺼내(pop),  그  합을  구한  후  다시  스택에  넣고(push) gas 를  1 만큼  감소시키고, pc 는  1  증가시킨다. SSTORE  는  스택에서  두  개의  아이템을  꺼내  이  아이템의  첫  번째  값이  가리키는  컨트랙트 저장소  인덱스에  두  번째  아이템을  넣는다.  이더리움  버추얼  머신  환경을  JIT  컴파일을  통해  최적화  하는  많은  방법이 있지만,  기본적인  이더리움은  수백줄의  코드로  구현될  수  있다.</p>
</blockquote>
<p>컨트렉트 코드가 실행 되는동안 계산상태는 튜플로 정의한다. 각각의 instruction 들은 (block_state, transaction, message, code, memory, stack, pc, gas) 튜플에 어떻게 영향을 미치는 지를 정의한다.
굴</p>
<h3 id="블록체인과--채굴blockchain-and-mining">블록체인과  채굴(Blockchain and Mining)</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/ethereum-white-paper/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC%EC%B1%84%EA%B5%B4.png"
        data-srcset="/images/ethereum-white-paper/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC%EC%B1%84%EA%B5%B4.png, /images/ethereum-white-paper/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC%EC%B1%84%EA%B5%B4.png 1.5x, /images/ethereum-white-paper/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC%EC%B1%84%EA%B5%B4.png 2x"
        data-sizes="auto"
        alt="/images/ethereum-white-paper/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC%EC%B1%84%EA%B5%B4.png"
        title="/images/ethereum-white-paper/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8%EA%B3%BC%EC%B1%84%EA%B5%B4.png" width="1800" height="321" /></p>
<blockquote>
<p>이더리움  블록체인은  여러면에서  비트코인  블록체인과  유사하나,  어느정도  차이점들이  있다.  이더리움과  비트코인에서의 각  블록체인  구조에  대한  주요  차이점으로는  비트코인과는  달리  <strong>이더리움  블록은  트랜잭션  리스트와  가장  최근의 상태(state)  복사본을  가지고  있다는  것이다.</strong>  그것  외에도,  두개의  다른  값  -  <strong>블록  넘버와  difficulty -  이  또한  블록내에 저장된다.</strong>  기본적인  이더리움  블록  검증  알고리즘은  다음과  같다.</p>
<ol>
<li>참조하고  있는  이전  블록이  존재하는지  그리고,  유효한지  확인한다.</li>
<li>현재  블록의  타임스탬프가  참조하고  있는  이전  블록의  그것보다  크면서,  동시에  현  시점을  기준으로  15 분 후보다  작은  값인지  확인한다.</li>
<li>블록  넘버, difficulty,  트랜잭션  루트,  삼촌  루트, gas  리미트등(기타  다양한  이더리움  로우  레벨  개념)이 유효한지  확인한다.</li>
<li>블록에  포함된  작업  증명이  유효한지  확인한다.</li>
<li>S[0]  이  이전  블록의  마지막  상태(state)라고  가정  하자.</li>
<li>TX 를  현재  블록의  n  개의  트랜잭션  리스트라고  하자. 0 부터  n-1  에  대해, S[i+1] = APPLY(S[i], TX[i])  로 설정하자.  어플리케이션이  오류를  반환하거나,  이  시점까지  블록에서  소모된  총  gas 가 GASLIMIT 를  초과하면 오류를  반환한다.</li>
<li>채굴자에게  지불된  보상  블록을  S[n]  덧붙인  후  이것을  S_FINAL  이라  하자.</li>
<li>상태  S_FINAL  의  머클  트리  루트가  블록  헤더가  가지고  있는  최종  상태  루트와  같은지를  검증한다.  이  값이 같으면  그  블록은  유효한  블록이며,  다르면  유효하지  않은  것으로  판단한다.</li>
</ol>
</blockquote>
<blockquote>
<p>이러한  접근은  언뜻,  <strong>모든  상태를  각  블록에  저장할  필요성  때문에  매우  비효율적인  것처럼  보이지만</strong>,  실제로는 효율성의  측면에서는  비트코인과  비교할만  하다.  그  이유로는  상태가  트리  구조로  저장되고,  모든  블록  후에  단지 트리의  작은  부분만이  변경되기  때문이다.  보통,  인접한  두개의  블록간에는  트리의  대부분의  내용이  같고,  따라서  한번 데이터가  저장되면  포인터(서브트리의  해쉬)를  사용하여  참조될  수  있다.  패트리시아  트리(Patricia tree)로  알려진 이러한  종류의  특별한  트리는  머클  트리  개념을  수정하여  노드를  단지  수정할  뿐만  아니라,  효율적으로  삽입되거나 삭제하여  이러한  작업을  수행할  수  있도록  해준다.  <strong>또한,  모든  상태  정보가  마지막  블록에  포함되어  있기  때문에,  전체 블록체인  히스토리를  모두  저장할  필요가  없어지게  된다.</strong>  이  방법을  비트코인에  적용한다면  5 - 20 배의  저장  공간 절약의  효과가  생길  것이다.</p>
</blockquote>
<p>비트코인과의 가장 주요한 차이점은 블록안에 가장 최근의 상태 S 를 가지고 있다는 것이다. 이것은 저장 공간에서 크게 손해가 되지 않는다.</p>
<ol>
<li>상태가 트리구조로 저장 될때 인접한 두개의 블록간의 내용은 거의 같기 때문에 상태의 상당부분을 대부분 참조만 하면된다.</li>
<li>모든 상태정보가 블록안에 포함 되어 있기때문에 블록체인 히스토리를 모두 저장할 필요가 없다. -&gt; 비트코인은 상태정보를 처음부터 끝까지 적용하여 검증한다.</li>
</ol>
<blockquote>
<p>물리적인  하드웨어  관점에서  볼  때,  컨트랙트  코드는  “어디에서&rdquo;  실행되는가  하는  의문이  쉽게  들  수  있다.  간단한 해답은  다음과  같다.  <strong>컨트랙트  코드를  실행하는  프로세스는  상태  전환  함수  정의의  한  부분이고,  이것은  블록  검증 알고리즘의  부분이다</strong>.  따라서,  트랜잭션이  블록  B 에  포함되면  그  트랜잭션에  의해  발생할  코드의  실행은  현재  또는 향후에  블록  B  를  다운로드  하고  검증하는  모든  노드들에  의해  실행될  것이다.</p>
</blockquote>
<p>컨트랙트 코드는 상태 전환 함수 정의에 포함 되어 있다.</p>
<h2 id="그--밖의--이슈miscellanea-and-concerns">그  밖의  이슈(Miscellanea And Concerns)</h2>
<h3 id="수수료fees">수수료(Fees)</h3>
<blockquote>
<p>블록체인에  올려지는  각  트랜잭션은  그것을  다운로드하고  검증하기  위한  비용을  네트워크에  부과하기  때문에,  남용을 방지하는  어떠한  규제  메커니즘,  일반적으로는  트랜잭션  수수료가  필요하게  된다.  비트코인에서  사용되는  기본적인 접근방법은  순수하게  자발적인  수수료를  징수하면서,  <strong>채굴자들이  게이트키퍼(gatekeeper)로서의  역할을  하고 유동적으로  최저액을  설정하도록  하는  것이다.</strong>    이런  접근방법은  비트코인  커뮤니티에서  매우  환영  받아왔는데, 그것이  “시장-기반”이기  때문에,  <strong>채굴자와  트랜잭션  송신자들간의  수요와  공급이  그  가격을  결정한다는  이유에서였다.</strong></p>
</blockquote>
<p>비트코인의 수수료는 채굴자들이 유동적으로 정하는 형태이다. 이는 시장 기반으로 수요와 공급의 원칙 에따라서 수수료의 가격이 정해 진다.</p>
<blockquote>
<p>하지만  이런  식의  사고방식에는  문제가  있는데,  트랜잭션  처리는  시장에서  일어나는  것이  아니라는  점이다.    트랜잭션 처리를  채굴자가  송신자에  제공하는  하나의  서비스로  해석하는  것이  직관적으로  솔깃해  보이기는  하지만, 실제적으로는  <strong>채굴자가  포함하는  모든  트랜잭션들은  네트워크의  모든  노드들에  의해  처리되어야  하고,  따라서 트랜잭션처리에  필요한  대부분의  비용은  제 3 자가  부담하는  것이지,  그  트랜잭션을  포함할지  말지를  결정하는 채굴자들이  아니라는  것이다.</strong>    그러므로  <strong>공유지의  비극(tragedy-of-the-commons)  문제</strong>들이  매우  일어나기  쉽다는 것이다.</p>
</blockquote>
<p>트랜잭션 처리는 직관적으로 시장 기반으로 보일 수 있지만 실제적으로는 고려해야 하는 부분이 있다.
트랜잭션 처리는 채굴자의 컴퓨터로만 처리되는 것이 아니라 모든 노드들이 힘을 합쳐서 처리 된다. <!-- raw HTML omitted --> 즉, 트랜잭션 처리에 대한 비용은 해당 채굴자만 부담하는 것이 아니므로 단순히 서비스로 해석하기에는 한계가 있다.</p>
<blockquote>
<p>하지만,  이러한  시장기반  메커니즘의  결함은  <strong>어떤  부정확한  단순화  전제들</strong>이  주워졌을  때,  마술처럼  그  결함자체를 상쇄하게  된다.  그  주장은  다음과  같다. 다음을  전제해  보자:</p>
<ol>
<li>하나의  트랜잭션이  k 개의  작업들(operations)을  초래하는데,  이  트랜잭션을  포함하는  채굴자에게  kR 만큼의
보상을  제공하게  된다.  여기서  <strong>R 은  송신자에  의해서  설정</strong>되고, k  와  R 은  (대략적으로)  채굴자에게  사전에 노출된다.</li>
<li>하나의  작업은  어떤  노드에  대해서든  C  만큼의  처리비용을  가진다(즉,  모든  노드들은  똑같은  효율성을  가지고
있다).</li>
<li><strong>N 개의  채굴노드들</strong>이  있고,  각각은  정확히  똑같은  처리파워(즉,  전체의  1/N)를  가지고  있다.</li>
<li>채굴을  하지  않는  완전노드(full nodes)는  없다.</li>
</ol>
</blockquote>
<blockquote>
<p>채굴자는  어떠한  트랜잭션이  그  비용보다  기대보상이  클  경우  처리하려고  할  것이다.  따라서,  기대  보상은  kR/N 인데, 왜냐하면  채굴자는  다음  번  블록을  처리할  1/N  확률을  가지고  있으며,  이  채굴자에게  처리비용은  단순히  kC 이다. 그러므로  채굴자들은  <strong>kR/N &gt; kC</strong>  이거나, <strong>R &gt; NC</strong> 일  때  트랜잭션들을  포함하려  할  것이다.    여기서  R 은  송신자에 의해  제공된  단위작업(pre-operation)당  수수료이고,  따라서  이것은  송신자가  그  트랜잭션에서  보게  될  혜택에  대한 &lsquo;하한값&rsquo;이  되고, NC 는  하나의  작업을  처리하기  위해  전체  네트워크에  부과된  비용임을  주목하자.  따라서  채굴자들은 비용보다  전체  공리적인  혜택이  큰  트랜잭션들만  포함하려  하는  인센티브를  갖게  된다.</p>
</blockquote>
<p>해당 보상 지급 방법은 N = 채굴 노드의 개수가 포함됨으로서 공유지의 비극 문제를 해결 할 수 있다.
왜냐하면 채굴자는 채굴 노드의 개수가 적은 트랜잭션을 처리 할때 더 많은 비용이 들게 되는데 그것에 대한 보상이 반영 되었다.</p>
<blockquote>
<p>하지만  현실에서는    이러한  가정들이  맞지  않는    몇  가지  중요한  차이들이  있다.</p>
<ol>
<li>채굴자는  다른  검증  노드들보다  트랜잭션을  처리하는데  더  많은  비용을  지불하게  되는데,  왜냐하면, <strong>추가적인 검증시간은  블록전파를  지연</strong>시키고,  따라서  블록이  스테일되는  확률을  증가시키기  때문이다.</li>
<li><strong>비채굴  완전노드(full note)들이  존재</strong>한다.</li>
<li><strong>채굴  파워의  분포는  실제로  심각하게  불평등</strong>하게  될  수  있다.</li>
<li>네트워크에  피해를  주는  이해관계를  가진  투기자들,  정치적  적,  그리고  일탈자들이  존재하고,  그들은  다른 검증노드가  지불하는  비용보다  훨씬  적은    비용이  들게  될  그런  컨트랙트들을  교묘하게  만들  수  있다.</li>
</ol>
</blockquote>
<blockquote>
<p>(1)은  채굴자가  더  적은  수의  트랜잭션들을  포함하게  되는  경향을  제공하게  되고, (2)는  NC 를  증가시키게  되며, 따라서  이  두  가지의  효과들은  부분적으로는  서로를  상쇄한다. (3)과  (4)가  주요한  문제인데,  이것들을  해결하기  위해, &lsquo;플<strong>로팅  상한값(floating cap)&lsquo;을  도입한다</strong>.  <strong>어떤  블록이던지  BLK_LIMIT_FACTOR  곱하기  장기  지수  이동평균(the long-term exponential moving average)보다  더  많은  오퍼레이션들을  가질  수  없다는  것이다.</strong>  정확히는: <!-- raw HTML omitted --><!-- raw HTML omitted --><code>blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) / EMA_FACTOR)</code>
<!-- raw HTML omitted --><!-- raw HTML omitted -->BLK_LIMIT_FACTOR  와  EMA_FACTOR 은  상수이며  각각  잠정적으로  65536 와  1.5 로  정해질  것이지만,  추후  분석 후에  바뀔  가능성이  많다.</p>
</blockquote>
<blockquote>
<p>비트코인에  있어서  큰  블록크기를  막는  또  다른  요인도  있다.  <strong>큰  블록이  전파되는  데에  더  오래  걸리기  때문에, 스테일  될  가능성이  높다는  점이다</strong>.  이더리움에서도  높은  가스(GAS)사용  블록은  전파되는데  더  오래  걸리는데,  그것은 크기가  물리적으로  크다는  점과,  트랜잭션  상태변환들(state transitions)을  검증  처리하는데  더  오래  걸린다는  점 때문에  그러하다.  이러한  지연  불이익(delay disincentive)은  비트코인의  경우에는  중요한  고려사항이지만,  이더리움의 경우에는  **GHOST 프로토콜 ** 덕분에  중요도가  낮아진다.  따라서  조정된  &lsquo;블록리미트(block limit)&lsquo;로  인해,  보다  안정적인 기본기준(baseline)을  얻을  수  있게  된다.</p>
</blockquote>
<ul>
<li>GHOST(Greedy Heaviest Object subTree) - 프로토콜가장 큰 무게를 가진 subtree&rsquo;를 선택하는 알고리즘</li>
</ul>
<h3 id="채굴--중앙집중화mining-centralization">채굴  중앙집중화(Mining Centralization)</h3>
<blockquote>
<p>비트코인  채굴  방식은,  목표  값(현재  기준  약  2192)보다  낮은  값이  나올  때까지,  블록헤더에  대한  &lsquo;SHA256  해싱&rsquo; 작업을  무한정  반복하는  것이다.  하지만  해당  방식에는  두  가지  약점이  존재한다.</p>
</blockquote>
<blockquote>
<p><strong>첫  번째는  현재  채굴참여에  대한  장벽이  매우  높아졌다는  것이다.</strong>  현재  채굴생태계는  ASIC(특수목적을  위해  전용으로 설계된  반도체로,  범용반도체에  비해  성능이  뛰어남)에  의해  완전히  잠식되었다.  이러한  ASIC 채굴기는  일반 GPU 채굴기  등에  비해  수  천배  이상의  효율을  가지는데,  따라서  ASIC 이  아닌  일반컴퓨터를  통한  일반사용자들의 채굴행위는  경쟁력에서  밀려  효용을  잃게  되었다.  과거의  채굴행위가  분권화되고  이타적인  참여자  중심의 ‘생태계’였다면,  현재는  수십억원의  투자가  되어야만  참여가  가능한  재력가들의  ‘사업’으로  변질되고  말았다.</p>
</blockquote>
<blockquote>
<ul>
<li>실제 비트코인 네트워크에 직접연결 되어 블록생성을 하는 노드의 수는 기하급수적으로 줄어들고 있다.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>개인들이 전체네크워크 해시점유율을 나눠가진 것이 아니라, 그 해시를 인 계받은 거대 풀(Pool) 소유주가 그것  각  채굴자가  상태정보(the state)에서  무작위의 을 독점하고 있기 때문이다.</li>
</ul>
</blockquote>
<blockquote>
<p>두  번째는  채굴방식이다.  이전처럼  여러  지역에서  여러  참여자가  블록생성에  참여하는  것이  아니라,  <strong>중앙집중화된 채굴풀(Mining pool)이  제공하는  블록헤더(block header)에  의존하여  채굴에 참여한다는  점이다.</strong>  이로  인한  부작용이  상당한데,  현재  기준으로는, 3 개  채굴풀들이 개인들의  컴퓨팅파워를  인계  받아서  무려  50%에  육박하는  해시를  간접적으로 통제하고  있다.  물론  해당  풀의  점유율이  50%를  넘어가기  전에  개인들이  다른 소규모  풀들로  이동을  할  수  있기  때문에,  풀들이  마음대로  자원을  남용할  수는 없겠지만,  이는  여전히  큰  문제이다.</p>
</blockquote>
<blockquote>
<p>이더리움의  채굴  방식은  조금  다르다.  각  채굴자가  상태정보(the state)에서  <strong>무작위의  정보를  가져와서,  무작위로  선택  된  최근  몇개의  블록내역을  해싱  작업하고  결과값을 내놓는  것이다.</strong>  이렇게  하게  되면  두  가지  이점이  있다.</p>
</blockquote>
<blockquote>
<p>첫번째는  이더리움  계약이  모든  종류의  컴퓨터  계산방식을  포괄할  수  있다는  점이다.  따라서  자연히  ASIC 도  모든 계산방식에  적합하게  설계되어야  하는데,  <strong>이렇게  되면  결국  ASIC 이라기  보다는  일종의  고성능  CPU 가  되는  셈이다. 즉  현실적으로  ASIC(주문형  전용반도체)  자체가  무용지물이  된다.</strong></p>
</blockquote>
<blockquote>
<p>두번째로,  채굴자들은  작업  시  전체  블록체인을  다운  받아 <strong>모든  이체내역을  검증해야  한다는  점이다.  이렇게  되면 중앙집중화  된  대형  풀이  필요없게  된다.</strong>  물론  대형풀  자체는  신규블록생성  보상을  균일하게  참여자들에게  배분해  주는 효과가  있긴  하지만,  그러한  효과는  P2P 형식의  풀(pool)을  통해서도  충분히 구현이  가능하다.  굳이  중앙집중형  풀(centralized pool)  방식을  사용할  필요가 없다.</p>
</blockquote>
<blockquote>
<ul>
<li>참여자 개개인들이 각자의 노드를 통해 채 굴을 하는 경우, 한 블록 당 오직 하나의 노드만 보상을 받기 때문에, 운이 없다면 평생 보상을 받지 못하는 경우도 생긴다. 이러한 도박성을 제거하기 위해 한 개의 노드가  참여자들을  대표해서  컴퓨팅파워 를 모으고 채굴작업을 하여 이로 인한 <strong>보 상을 기여도에 따라 균등히 참여자들에게 배분함</strong>으로써, 해당 작업에 참여한 모두가 <strong>소량의 안정적 수익을 얻을 수 있게 해준 다.</strong> 연합채굴(mining pool) 행위는 블록생 성작업에 대해 균일성과 예측성을 제공함 으로써, 블록생성을 단순한  &lsquo;도박&rsquo;에서, 경 영이 가능한 &lsquo;사업&rsquo;으로 바꾸어 놓았다.</li>
</ul>
</blockquote>
<blockquote>
<p>물론  위의  채굴  모델이  아직  검증된  것은  아니다.  또한  ASIC 장비에  대한 저항성을  높이는  작업도,  이론처럼  현실에서  적용이  될  수  있을지에  대하여는 의문의  여지가  있다.  하지만  한  가지  확실한  것은,  여러종류의  수많은  계약이 적용이  되면,  이를  모두  포괄하는  ASIC 을  예전처럼  만들어  내기는  어렵다는 점이다.  또한  어떠한  종류의  작업에  특화  된  ASIC 이  존재한다면,  이에  반하는 작업을  요하는  계약이  생성되는  것을  원치  않을  것이다.  그러면  해당 ASIC 채굴자의  경쟁자는  그에  적대적인,  즉  비효율적인  작업을  요하는  계약들을 생성해  냄으로써  공격을  가할  것이다.  <strong>즉,  각  부분에  특화된  ASIC 을  소유한 채굴자들은  서로에게  불리한  작업을  하게하는  계약들을  만들어  냄으로써  서로를 공격할  것이다.  물론  이러한  방법은  ‘기술적’인  접근이라기보다는  ‘경제학적 인간행동론’에  근거한  접근에  가깝다.</strong></p>
</blockquote>
<p>또다른 맞춤형 반도체가 나오더라도 각각의 ASIC 소유 채굴자들은 서로에게 불리한 작업을 할것이다.
-&gt; 기술적인 해결책 보다는 경제학적 인간행동론에 기반하여 예측 (보장되지는 않는다)</p>
<h3 id="확장성scalability">확장성(Scalability)</h3>
<blockquote>
<p>이더리움에  대한  한  가지  공통된  의문점은  확장성  부분이다.  비트코인과  마찬가지로  이더리움도  모든  이체작업이 네크워크  상의  전체  노드에  의해서  일일이  검증  및  작업이  되어야  한다는  약점이  있다.  비트코인의  경우,  현재  전체 블록체인의  크기가  약  15GB 에  이르며,  그  크기는  매  시간  1MB 씩  꾸준히  늘어나고  있다. VISA 의  경우  초당 2,000 여  건의  이체작업을  처리하는데,  이는  매  3 초당  1MB 씩의  확장(시간  당  1GB,  매  년  8TB)을  의미한다. 이더리움도  비슷한  문제를  겪을  것이고,  단순히  화폐로써의  역할  만하는  비트코인에  비한다면,  온갖  종류의 탈중앙화된  어플리케이션들(Dapps: Decentralized applications)을  포괄하는  이더리움은  이  부분에서  훨씬  더  많은 문제를  겪을  수도  있을  것이다.  하지만  한  가지  다른  점은,  이더리움은  ‘전체  블록체인  히스토리’가  아닌,  단지  ‘상태 정보(the state)’만  가지고  있으면  된다는  점이다.</p>
</blockquote>
<p>이더리움도 단순한 화폐 기능만 하는 비트코인과 비교하면 많은 어플리케이션들을 포괄하기 때문에 시간이 지날 수록 저장공간에 대한 한계에 부딪치게 될 것이다. 그나마 괜찮은 점은 &lsquo;상태정보&rsquo;만 가지고 있으면 되기 때문에 보완이 될 수 있다.</p>
<blockquote>
<p>만일  개개의  모든  노드가  전체  블록체인을  보관해야  한다면,  아래와  같은  문제가 생길  수  있다.  블록체인의  크기가  점점  커져  100TB 에  육박하게  되었다고 생각해보자.  이  정도  수준으로  보관해야  하는  블록체인의  크기가  커지면,  오직 소수의  사업가나  기업  형태의  참여자만이  이를  감당할  수  있게  된다.  다수의  일반 사용자들은  ‘라이트 SPV(Simple Payment Verification)’  노드만들  사용하게  될 것이다.  이렇게  되면,  전체  블록체인의  내역을  가진  소수의  참여자들이  결탁하여, 장부내역을  수정하거나  블록보상량을  바꿔치기  하는  등의  조작행위가  일어날  수 있을  것이다.  <strong>단순한  ‘라이트  노드(light node)’로써는  이러한  조작을  감지할  방법이  없다.</strong>  물론  ‘전체  블록체인를  소유한  노드(full node)’  중에서도  선의의  참가자가 있을지  모른다.  그러나  다수의  ‘완전노드(full node)’가  작심하여  블록체인  조작을 시도한다면,  이를  발견하는  시점에서는  이미  늦었다고  봐야  할  것이다.  실제로 비트코인이  현재  이와  비슷한  문제에  처할  위험이  있다고  경고받고  있으며,  해당 문제를  완화시키는  방법에  대하여는  Peter Todd 에  의해  논의된  바  있다.</p>
</blockquote>
<blockquote>
<ul>
<li>완전노드(full node)- &lsquo;전체노드&rsquo;를 의미 하는 것이 아니라, &lsquo;탄생블록(genesis block)&lsquo;에서부터 &lsquo;최근블록(current block)&lsquo;에 이르는 블록체인 &lsquo;전체장부&rsquo; 를 가지고 있는 노드를 가리킨다.</li>
</ul>
</blockquote>
<blockquote>
<p>위의  문제를  해결키  위해,  가까운  시일  안에  두  가지의  전략을  추가로  도입할  예정이다.  <strong>첫  번째로  이더리움도 기본적으로  블록체인  기술을  바탕으로  한  채굴  알고리즘을  사용하고  있기  때문에,  모든  채굴자들은  ‘완전노드(full node)’가  되도록  의무화</strong>  될  것이며,  이는  필요한  최소한의  완전노드  숫자를  확보할  수  있도록  해줄  것이다  .  <strong>두번째로, 이체내역  검증  작업  이후  블록체인에  ‘중간상태  트리루트(an intermediate state tree root)’를  도입하는  것이다.</strong>  이렇게 되면,  아무리  블록생성  작업이  소수의  노드에  집중되더라도,  단  하나의  &lsquo;선의의  노드(honest node)&lsquo;만  존재한다면  검증 프로토콜(verification protocol)을  통해  이  문제를  해결할  수  있다.</p>
</blockquote>
<blockquote>
<p>만일  어떠한  채굴노드가  전파한  블록이  검증오류(invalid)처리가  되었다면,  해당  블록의  ‘구성(format)’이  맞지  않거나 ‘상태내역  S [ n ]’이  틀린  경우일  것이다. ‘S [ 0 ]’  상태가  옳은  것으로  간주되기  때문에, ‘S[ i-1 ]’이  맞다면, ‘S[ i ]’에  오류가  있는  것이다.  검증작업에  참여하는  노드는, ‘APPLY(S[i-1],TX[i]) -&gt; S[i]’  작업(processing)을  하는 ‘<strong>페트리샤  트리  노드의  부분집합(the subset of Patricia tree)’을  통해  ‘검증오류증명(proof of invalidity)’과  ‘인덱스 i’를  제공한다.  노드들은,  위의  노드들을  이용해  해당  작업을  수행하며,  생성한  ‘S[ i ]’가  제공받은  ‘S[ i ]’와  일치하지 않음을  발견하게  된다.</strong></p>
</blockquote>
<p>중간상태 트리루트 - 검증오류증명 과 인덱스를 제공하여 중간 상태가 유효한지 검증한다.</p>
<blockquote>
<p>또한  ‘불완전한  블록(incomplete block)’을  전파하려는  악의의  채굴노드들과  관련된  더욱  정교한  공격이  이루어질  수 있다.  블록을  검증하는데에  필요한  정보가  온전히  존재하지  않을  수도  있다.  이  경우, <strong>‘질의-응답프로토콜(challenge- response protocol)’  기법</strong>이  사용될  수  있다.  <strong>검증노드가  ‘목표  블록의  인덱스  형태 (target transaction indices)’로  ‘질문(challenge)’을  생성</strong>하고,  노드를  수신하는 라이트노드(light  node)는  해당  블록(challenge)을  <strong>일단  검증오류블록으로  취급한다.</strong> 이후,  다른  노드(채굴노드이든  검증노드이든)가  ‘<strong>페트리샤  트리  노드의  부분집합 (the subset of Patricia tree)’을  검증증명(proof of validity)으로써  제공한다면, 그때서  위의  블록은  검증된(유효한)  것으로  취급된다.</strong></p>
</blockquote>
<p>질의 응답 프로토콜 - 라이트노드는 일단 검증 해야하는 노드를 일단 오류블록으로 취급한 뒤에 다른 노드가 검증증명을 제공하면 그때 다시 검증된 것으로 취급한다.</p>
<blockquote>
<ul>
<li>전자여권, 보안카드 등의 인증기법에서 흔히 사용되는 방법으로, 사실상 웹싸이 트에 로그인 하기 위한 &lsquo;비밀번호&rsquo; 도 이 기법의 일종으로 볼 수 있다. 일정한 질문에 대해 올바른 답변을 하 는 것으로 신원을 증명하며, 질문을 예측불허하게 계속  바꿈으로써 해킹시도 를 무력화 시킨다. 다중비밀번호 설정이 나, 보안카드가 좋은 예가 될 수 있다.</li>
</ul>
</blockquote>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2023-03-26</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="http://jwanp.github.io/posts/ethereum-white-paper/" data-title="Ethereum White Paper" data-hashtags="block-chain"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="http://jwanp.github.io/posts/ethereum-white-paper/" data-hashtag="block-chain"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Linkedin" data-sharer="linkedin" data-url="http://jwanp.github.io/posts/ethereum-white-paper/"><i class="fab fa-linkedin fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="http://jwanp.github.io/posts/ethereum-white-paper/" data-title="Ethereum White Paper"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="http://jwanp.github.io/posts/ethereum-white-paper/" data-title="Ethereum White Paper"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="http://jwanp.github.io/posts/ethereum-white-paper/" data-title="Ethereum White Paper" data-image="/images/ethereum-white-paper/ethereum-main.png"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Blogger" data-sharer="blogger" data-url="http://jwanp.github.io/posts/ethereum-white-paper/" data-title="Ethereum White Paper" data-description=""><i class="fab fa-blogger fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/block-chain/">block-chain</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/bitcoin-white-paper/" class="prev" rel="prev" title="Bitcoin White Paper"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>Bitcoin White Paper</a>
            <a href="/posts/minting-nft/" class="next" rel="next" title="Minting Nft">Minting Nft<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="utterances" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://utteranc.es/">utterances</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.111.3">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">박주환</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"Comment","lightTheme":"github-light","repo":"jwanp/blog-comment"}},"search":{"algoliaAppID":"6QK332EH1T","algoliaIndex":"jwanp","algoliaSearchKey":"79b39b96ee30ec1c39a4bf1a4037c605","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":30,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-DZ2VH32QXR', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-DZ2VH32QXR" async></script></body>
</html>
